

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spicy_class &mdash; SPICY 1.0.5 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css?v=7f9a90b1" />

  
      <script src="../_static/documentation_options.js?v=d55fa986"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            SPICY
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">SPICY: Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../min_versions.html">Minimum Version of Python and NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../material.html">SPICY: References and material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../version_history.html">Release History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SPICY</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">spicy_class</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spicy_class</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Latest update on Thu Apr 27 13:40:44 2023</span>

<span class="sd">@author: mendez, ratz, sperotto</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> <span class="c1"># used in all computations</span>

<span class="c1"># these functions are used for the clutering and collocation</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>
<span class="c1"># Function for the k means clusering</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">MiniBatchKMeans</span>

<span class="c1"># Note: there is a warning from kmeans when running on windows.</span>
<span class="c1"># This should fix it</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

<span class="c1"># Matplotlib for the plotting functions:</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># function useful for computing smallsest and largest eig:</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">eigsh</span>
<span class="c1"># we use scipy linalg for cholesky decomposition, solving linear systems etc</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>

<span class="c1"># We use this function to handle polygonal refinements areas</span>
<span class="kn">from</span> <span class="nn">shapely</span> <span class="kn">import</span> <span class="n">geometry</span>


<div class="viewcode-block" id="spicy">
<a class="viewcode-back" href="../usage.html#spicy_class.spicy">[docs]</a>
<span class="k">class</span> <span class="nc">spicy</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SPICY (Super-resolution and Pressure from Image veloCimetrY) is a software</span>
<span class="sd">    developed at the von Karman Institute to perform data assimilation by means</span>
<span class="sd">    of Radial Basis Functions (RBF). The framework works both for structured and</span>
<span class="sd">    unstructered data. Currently, the main application is to perform a regression</span>
<span class="sd">    of image velocimetry data and then solve the pressure equation. However, the framework</span>
<span class="sd">    can be readily extended to regression of other fields (e.g. temperature fields).</span>

<span class="sd">    The original article by Sperotto et al. (2022) can be found at:</span>
<span class="sd">    https://arxiv.org/abs/2112.12752</span>

<span class="sd">    YouTube channel with hands-on tutorials can be found at:</span>
<span class="sd">    https://www.youtube.com/@spicyVKI</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1. Initialize the class with the data</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">grid_point</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">ST</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization of an instance of the spicy class.</span>

<span class="sd">        :type data: list of 1D numpy.ndarray</span>
<span class="sd">        :param data:</span>
<span class="sd">            If the instance is to be used to solve a regression problem, this</span>
<span class="sd">            list contains the target data. data is an array [u] if the model is</span>
<span class="sd">            scalar, a list with two arrays [u, v] for a 2D vector field and a list of</span>
<span class="sd">            three arrays [u, v, w] for a 3D field.</span>
<span class="sd">            If the instance is to be used to solve the Poisson equation,</span>
<span class="sd">            this list contains the forcing term on the RHS of the Poisson equation.</span>

<span class="sd">        :type grid point: list of 1D numpy.ndarray</span>
<span class="sd">        :param grid_point:</span>
<span class="sd">            Is a list of arrays containing the grid points: [X_G ,Y_G] in 2D and</span>
<span class="sd">            [X_G, Y_G, Z_G] in 3D.</span>

<span class="sd">        :type basis: str</span>
<span class="sd">        :param basis: This defines the basis. Currently, the two options are</span>

<span class="sd">           - ``&#39;gauss&#39;``, i.e. Gaussian RBFs exp(-c_r**2*d(x))</span>
<span class="sd">           - ``&#39;c4&#39;``, i.e. C4 RBFs (1+d(x+)/c_r)**5(1-d(x+)/c_r)**5</span>

<span class="sd">        :type ST: list of 1D numpy.ndarray</span>
<span class="sd">        :param ST:</span>
<span class="sd">            Is a list of arrays collecting Reynolds stresses. This is empty if</span>
<span class="sd">            the model is &#39;scalar&#39; or &#39;laminar&#39;. If the model is RANSI (isotropic), it</span>
<span class="sd">            contains [uu&#39;]. If the model is RANSA (anisotropic), it contains [uu, vv, uv]</span>
<span class="sd">            in 2D and [uu, vv, ww, uv, uw, vw] in 3D.</span>

<span class="sd">        General attributes:</span>
<span class="sd">            X_G, Y_G, Z_G: coordinates of the point in which the data is available</span>
<span class="sd">            u : function to learn or u component in case of velocity field</span>
<span class="sd">            v: v component in case of velocity field (absent for scalar)</span>
<span class="sd">            w: w component in case of velocity field (absent for scalar)</span>

<span class="sd">        If constraints are assigned:</span>
<span class="sd">            X_D, Y_D, Z_D: coordinates of the points with Dirichlet (D) conditions</span>
<span class="sd">            c_D: values of the D conditions</span>

<span class="sd">            X_N, Y_N, Z_N: coordinates of the points with Neumann (N) conditions</span>
<span class="sd">            n_x, n_y, n_z: normal versors where N conditions are introduced</span>
<span class="sd">            c_N_X, c_N_Y, c_N_Z: values of the N conditions</span>

<span class="sd">            X_Div, Y_Div, Z_Div: coordinates of the points with Div conditions</span>

<span class="sd">        If clustering is done:</span>
<span class="sd">            r_mM: vector collecting minimum (m) and maximum (M) radious of the RBFs</span>
<span class="sd">            eps_l: scalar controlling the value of an RBF at the closest RBF neighbor</span>
<span class="sd">            X_C, Y_C, Z_C : coordinates of the cluster centers/collocations</span>
<span class="sd">            c_k: shape parameters of the RBFs</span>
<span class="sd">            d_k: diameters of the rbfs</span>

<span class="sd">        If problem is assembled:</span>
<span class="sd">            A: matrix A in the linear system</span>
<span class="sd">            B: matrix B in the linear system</span>
<span class="sd">            b_1: vector b_1 in the linear systems</span>
<span class="sd">            b_2: vector b_2 in the linear system</span>

<span class="sd">        If computation is done:</span>
<span class="sd">            weights: weights of the RBF regression</span>
<span class="sd">            lambda: Lagrange multipliers of the RBF regression</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check the input is correct</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;Input data must be a list&#39;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid_point</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;Input grid_point must be a list&#39;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;Input basis must be a string&#39;</span>
        <span class="k">assert</span> <span class="n">ST</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">ST</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;Input ST must be a </span><span class="se">\&#39;</span><span class="s1">None</span><span class="se">\&#39;</span><span class="s1"> or a list&#39;</span>

        <span class="c1"># Assign the basis</span>
        <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span> <span class="ow">or</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="n">basis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong basis type, must be either </span><span class="se">\&#39;</span><span class="s1">gauss</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">c4</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Check the length of the grid points to see if it is 2D or 3D</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_point</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># 2D problem</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s1">&#39;2D&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_G</span> <span class="o">=</span> <span class="n">grid_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span> <span class="o">=</span> <span class="n">grid_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># check the data</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># scalar</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;scalar&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># laminar</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;laminar&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;When grid_point is [X_g, Y_g], </span><span class="se">\&#39;</span><span class="s1">data</span><span class="se">\&#39;</span><span class="s1"> must either be [u] or [u,v]&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ST</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># reynolds stress model</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;RANSI/RANSA currently not implemented in 2D&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_point</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># 3D problem</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s1">&#39;3D&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_G</span> <span class="o">=</span> <span class="n">grid_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span> <span class="o">=</span> <span class="n">grid_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span> <span class="o">=</span> <span class="n">grid_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;scalar&#39;</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;laminar&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;When grid_point is [X_g, Y_g, Z_g], </span><span class="se">\&#39;</span><span class="s1">data</span><span class="se">\&#39;</span><span class="s1"> must either be [u] or [u,v,w]&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ST</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;RANSI/RANSA currently not implemented in 3D&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid size of input grid, currently only implemented in 2D and 3D&#39;</span><span class="p">)</span>

        <span class="c1"># Assign the number of data points. This is the same in all cases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">)</span>

        <span class="k">return</span>


    <span class="c1"># 2. Clustering (this does not depend on the model, but only on the dimension).</span>
    <span class="k">def</span> <span class="nf">clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_K</span><span class="p">,</span> <span class="n">Areas</span><span class="p">,</span> <span class="n">r_mM</span><span class="o">=</span><span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">eps_l</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function defines the collocation of a set of RBFs using the multi-</span>
<span class="sd">        level clustering first introduced in the article. Note that we modified the slightly original formulation</span>
<span class="sd">        to ease the programming; see video tutorials for more.</span>
<span class="sd">        The function must be run before the constraint definition.</span>

<span class="sd">        :type n_K: list</span>
<span class="sd">        :param n_K:</span>
<span class="sd">            This contains the n_k vector in eq (33) in the paper; this is the</span>
<span class="sd">            list of expected particles per RBF at each level. For example, if n_K=[4,10],</span>
<span class="sd">            it means that the clustering will try to have a first level with RBFs whose size</span>
<span class="sd">            seeks to embrace 4 points, while the second level seeks to embrace</span>
<span class="sd">            10 points, etc. The length of this vector automatically defines the</span>
<span class="sd">            number of levels.</span>

<span class="sd">        :type Areas: list</span>
<span class="sd">        :param Areas:</span>
<span class="sd">            List of the refinement regions for each clustering level. If no</span>
<span class="sd">            refinement is needed, then this should be a list of empty</span>
<span class="sd">            lists (default option). Currently not implemented in 3D.</span>

<span class="sd">        :type r_mM: list of two float values</span>
<span class="sd">        :param r_mM: default=[0.01, 0.3].</span>
<span class="sd">            This contains the minimum and the maximum RBF&#39;s radiuses. This is</span>
<span class="sd">            defined as the distance from the collocation point at which the RBF</span>
<span class="sd">            value is 0.5.</span>

<span class="sd">        :type float: float</span>
<span class="sd">        :param eps_l: default=0.7.</span>
<span class="sd">            This is the value that a RBF will have at its closest neighbour. It</span>
<span class="sd">            is used to define the shape factor from the clustering results.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check the input is correct</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">n_K</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;Clustering levels must be given as a list&#39;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">r_mM</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_mM</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;r_mM must be a list of length 2&#39;</span>
        <span class="k">assert</span> <span class="n">r_mM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">r_mM</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;Minimum radius must be smaller than maximum radius&#39;</span>
        <span class="k">assert</span> <span class="n">eps_l</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">eps_l</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;eps_l must be between zero and 1&#39;</span>

        <span class="c1"># we assign the clustering parameters to self</span>
        <span class="c1"># they are needed in the constraints to set the shape parameters for the</span>
        <span class="c1"># RBFs which are located at constraint points</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">r_mM</span> <span class="o">=</span> <span class="n">r_mM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps_l</span> <span class="o">=</span> <span class="n">eps_l</span>

        <span class="c1"># Check if we are dealing with a 2D or a 3D case</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">==</span><span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># This is 2D</span>

            <span class="c1"># Number of levels</span>
            <span class="n">n_l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_K</span><span class="p">)</span>

            <span class="c1"># Loop over the number of levels</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_l</span><span class="p">):</span>
                <span class="c1"># We look for the points that belongs to the given area:</span>
                <span class="k">if</span> <span class="n">Areas</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span>
                    <span class="c1"># This means a polygon object is given, so take only points</span>
                    <span class="c1"># inside this:</span>
                    <span class="n">poly</span> <span class="o">=</span> <span class="n">Areas</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
                    <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># prepare empty list</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">)):</span> <span class="c1"># fill list of points in poly</span>
                        <span class="n">List</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">[</span><span class="n">j</span><span class="p">])))</span>
                    <span class="c1"># Take only these points as data matrix</span>
                    <span class="n">X_G_c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">[</span><span class="n">List</span><span class="p">]</span>
                    <span class="n">Y_G_c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">[</span><span class="n">List</span><span class="p">]</span>
                    <span class="n">Data_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">X_G_c</span><span class="p">,</span> <span class="n">Y_G_c</span><span class="p">))</span>
                    <span class="n">List</span><span class="o">=</span><span class="p">[]</span> <span class="c1"># delete the list for safety</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># if Areas is empty then all points should be included</span>
                    <span class="n">Data_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">))</span>

                <span class="c1"># Define number of clusters</span>
                <span class="n">Clust</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Data_matrix</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span> <span class="n">n_K</span><span class="p">[</span><span class="n">l</span><span class="p">]))</span>

                <span class="c1"># Initialize the cluster function</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">MiniBatchKMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">Clust</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># Run the clustering and return the indices (optional)</span>
                <span class="n">y_P</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">Data_matrix</span><span class="p">)</span>
                <span class="c1"># Obtaining the centers of the points</span>
                <span class="n">Centers</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cluster_centers_</span>

                <span class="c1"># Get the nearest neighbour of each center</span>
                <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;ball_tree&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Centers</span><span class="p">)</span>
                <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">Centers</span><span class="p">)</span>
                <span class="n">sigma1</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Remove all of the clusters which either have a distance of</span>
                <span class="c1"># zero to the nearest neighbor (that would be the same RBF)</span>
                <span class="c1"># and the clusters with only one point in them</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">y_P</span><span class="p">,</span> <span class="n">minlength</span> <span class="o">=</span> <span class="n">Clust</span><span class="p">)</span>
                <span class="n">sigma1</span><span class="p">[</span><span class="n">sigma1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">sigma1</span><span class="p">[</span><span class="n">sigma1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">sigma1</span><span class="p">[</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">sigma1</span><span class="p">)</span>

                <span class="c1"># Pre-assign the collocation points</span>
                <span class="n">X_C1</span> <span class="o">=</span> <span class="n">Centers</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Y_C1</span> <span class="o">=</span> <span class="n">Centers</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">list_Index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X_C1</span><span class="p">))</span> <span class="c1"># to use also hstack</span>

                <span class="c1"># Assign the results to a vector of collocation points</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># If this is the first layer, just assign:</span>
                    <span class="n">X_C</span> <span class="o">=</span> <span class="n">X_C1</span>
                    <span class="n">Y_C</span> <span class="o">=</span> <span class="n">Y_C1</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma1</span>
                    <span class="n">l_list</span> <span class="o">=</span> <span class="n">list_Index</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># Stack onto the existing ones</span>
                    <span class="n">X_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X_C</span><span class="p">,</span> <span class="n">X_C1</span><span class="p">))</span>
                    <span class="n">Y_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Y_C</span><span class="p">,</span> <span class="n">Y_C1</span><span class="p">))</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigma</span><span class="p">,</span> <span class="n">sigma1</span><span class="p">))</span>
                    <span class="n">l_list</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">l_list</span><span class="p">,</span><span class="n">list_Index</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Clustering level &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; completed&#39;</span><span class="p">)</span>

            <span class="c1"># Assign to the class</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span> <span class="o">=</span> <span class="n">X_C</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span> <span class="o">=</span> <span class="n">Y_C</span>
            <span class="c1"># For plotting purposes, we keep track of the scale at which</span>
            <span class="c1"># the RBF have been places</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Clust_list</span><span class="o">=</span><span class="n">l_list</span>



        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span> <span class="c1"># This is 3D</span>
            <span class="c1"># Stack the coordinates in a matrix:</span>
            <span class="n">Data_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">))</span>
            <span class="c1"># Number of levels</span>
            <span class="n">n_l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_K</span><span class="p">)</span>

            <span class="c1"># Loop over the number of levels</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_l</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">Areas</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Areas currently only work in 2D&#39;</span><span class="p">)</span>
                <span class="c1"># Define number of clusters</span>
                <span class="n">Clust</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_p</span> <span class="o">/</span> <span class="n">n_K</span><span class="p">[</span><span class="n">l</span><span class="p">]))</span>
                <span class="c1"># Initialize the cluster function</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">MiniBatchKMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">Clust</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># Run the clustering and return the indices (optional)</span>
                <span class="n">y_P</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">Data_matrix</span><span class="p">)</span>
                <span class="c1"># Obtaining the centers of the points</span>
                <span class="n">Centers</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cluster_centers_</span>

                <span class="c1"># Get the nearest neighbour of each center</span>
                <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;ball_tree&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Centers</span><span class="p">)</span>
                <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">Centers</span><span class="p">)</span>
                <span class="n">sigma1</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Remove all of the clusters which either have a distance of</span>
                <span class="c1"># zero to the nearest neighbor (that would be the same RBF)</span>
                <span class="c1"># and the clusters with only one point in them</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">y_P</span><span class="p">,</span> <span class="n">minlength</span> <span class="o">=</span> <span class="n">Clust</span><span class="p">)</span>
                <span class="n">sigma1</span><span class="p">[</span><span class="n">sigma1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">sigma1</span><span class="p">[</span><span class="n">sigma1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">sigma1</span><span class="p">[</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">sigma1</span><span class="p">)</span>

                <span class="c1"># Pre-assign the collocation points</span>
                <span class="n">X_C1</span> <span class="o">=</span> <span class="n">Centers</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Y_C1</span> <span class="o">=</span> <span class="n">Centers</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">Z_C1</span> <span class="o">=</span> <span class="n">Centers</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>

                <span class="c1"># Assign the results to a vector of collocation points</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># If this is the first layer, just assign:</span>
                    <span class="n">X_C</span> <span class="o">=</span> <span class="n">X_C1</span>
                    <span class="n">Y_C</span> <span class="o">=</span> <span class="n">Y_C1</span>
                    <span class="n">Z_C</span> <span class="o">=</span> <span class="n">Z_C1</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma1</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># Stack onto the existing ones</span>
                    <span class="n">X_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X_C</span><span class="p">,</span> <span class="n">X_C1</span><span class="p">))</span>
                    <span class="n">Y_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Y_C</span><span class="p">,</span> <span class="n">Y_C1</span><span class="p">))</span>
                    <span class="n">Z_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Z_C</span><span class="p">,</span> <span class="n">Z_C1</span><span class="p">))</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigma</span><span class="p">,</span> <span class="n">sigma1</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Clustering level &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; completed&#39;</span><span class="p">)</span>

            <span class="c1"># Assign to the class</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span> <span class="o">=</span> <span class="n">X_C</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span> <span class="o">=</span> <span class="n">Y_C</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span> <span class="o">=</span> <span class="n">Z_C</span>

        <span class="c1"># We conclude with the computation of the shape factors. These depend</span>
        <span class="c1"># on the type of RBF but not whether the type is 2D or 3D.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">==</span><span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
            <span class="c1"># Set the max and min values of c_k</span>
            <span class="n">c_min</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">r_mM</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">c_max</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">r_mM</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="c1"># compute the c_k</span>
            <span class="n">c_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">eps_l</span><span class="p">))</span><span class="o">/</span><span class="n">sigma</span>
            <span class="c1"># crop to the minimum and maximum value</span>
            <span class="n">c_k</span><span class="p">[</span><span class="n">c_k</span> <span class="o">&lt;</span> <span class="n">c_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_min</span>
            <span class="n">c_k</span><span class="p">[</span><span class="n">c_k</span> <span class="o">&gt;</span> <span class="n">c_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_max</span>
            <span class="c1"># for plotting purposes, we store also the diameters</span>
            <span class="n">d_k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">c_k</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span>
            <span class="c1"># Set the max and min values of c_k</span>
            <span class="n">c_min</span> <span class="o">=</span> <span class="n">r_mM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">**</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="n">c_max</span> <span class="o">=</span> <span class="n">r_mM</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">**</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="c1"># compute the c _k</span>
            <span class="n">c_k</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">eps_l</span><span class="o">**</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="c1"># crop to the minimum and maximum value</span>
            <span class="n">c_k</span><span class="p">[</span><span class="n">c_k</span> <span class="o">&lt;</span> <span class="n">c_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_min</span>
            <span class="n">c_k</span><span class="p">[</span><span class="n">c_k</span> <span class="o">&gt;</span> <span class="n">c_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_max</span>
            <span class="c1"># for plotting purposes, we store also the diameters</span>
            <span class="n">d_k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">c_k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">**</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span> <span class="o">=</span> <span class="n">c_k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_k</span> <span class="o">=</span> <span class="n">d_k</span>

        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_C</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; RBFs placed through clustering&#39;</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="c1"># 3. Constraints.</span>

    <span class="c1"># We have two sorts of constraints: scalar and vector.</span>
    <span class="c1"># scalar apply to model = scalar and to the poisson solvers.</span>
    <span class="c1"># vector apply to all the other models.</span>

    <span class="c1"># the scalar ones include: Dirichlet and Neuman.</span>
    <span class="c1"># the vector one include: Dirichlet, Neuman and Div free.</span>

    <span class="c1"># 3.1 Scalar constraints</span>
    <span class="k">def</span> <span class="nf">scalar_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DIR</span><span class="o">=</span><span class="p">[],</span> <span class="n">NEU</span><span class="o">=</span><span class="p">[],</span> <span class="n">extra_RBF</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This functions sets the boundary conditions for a scalar problem. The</span>
<span class="sd">        function must be run after the clustering is carried out.</span>

<span class="sd">        :type DIR: list of 1D numpy.ndarray</span>
<span class="sd">        :param DIR:</span>
<span class="sd">            This contains the info for the Dirichlet conditions. If the model is</span>
<span class="sd">            2D, then this has [X_D, Y_D, c_D]. If the model is 3D, then this has</span>
<span class="sd">            [X_D, Y_D, Z_D, c_D]. Here X_D, Y_D, Z_D are the coordinates of the</span>
<span class="sd">            poins where the value c_D is set.</span>

<span class="sd">        :type NEU: list of 1D numpy.ndarray</span>
<span class="sd">        :param NEU:</span>
<span class="sd">            This contains the info for the Neuman conditions. If the model is 2D,</span>
<span class="sd">            then this has [X_N, Y_N, n_x, n_y, c_N]. If the model is 3D, then</span>
<span class="sd">            this has [X_N, Y_N, Z_N, n_x, n_y, n_z, c_N]. Here X_N, Y_N, Z_N are</span>
<span class="sd">            the coordinates of the poins where the value c_N is set for the</span>
<span class="sd">            directional derivative along the normal direction n_x, n_y, n_z.</span>

<span class="sd">        :type extra_RBF: bool</span>
<span class="sd">        :param extra_RBF: default = True</span>
<span class="sd">            This is a flag to put extra collocation points where a constraint is</span>
<span class="sd">            set. It can improve the solution of the linear system as constraints</span>
<span class="sd">            remove degrees of freedom.</span>

<span class="sd">        .. versionadded:: 2.5</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check the input is correct</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">DIR</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;DIR must be a list&#39;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">NEU</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;NEU must be a list&#39;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">extra_RBF</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">,</span> <span class="s1">&#39;extra_RBF must be a boolean&#39;</span>

        <span class="c1"># Check for Dirichlet conditions</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">DIR</span><span class="p">:</span> <span class="c1"># We have no Dirichlet conditions</span>
            <span class="c1"># We still assign empty arrays so that the assembly of the system is easier</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_D</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="c1"># In 3D, we must add the z term</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Z_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># We have Dirichlet conditions</span>
            <span class="c1"># Check if we have 2D or a 3D problem.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">DIR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_D</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_D</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">DIR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span> <span class="c1"># 3D</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_D</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Z_D</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_D</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of Dirichlet conditions does not fit for Type &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

        <span class="c1"># Check for Neuman conditions</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">NEU</span><span class="p">:</span> <span class="c1"># We have no Neumann conditions</span>
            <span class="c1"># We still assign empty arrays so that the assembly of the system is easier</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_N</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="c1"># In 3D, we must add the z term</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># We have Neumann conditions</span>
            <span class="c1"># Check if we have 2D or a 3D problem.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NEU</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NEU</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_N</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_N</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">NEU</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span> <span class="c1"># 3D</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NEU</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_N</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_z</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_N</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of Neumann conditions does not fit for Type &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

        <span class="c1"># Finally, we add the extra RBFs in the constraint points if desired</span>
        <span class="k">if</span> <span class="n">extra_RBF</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Check if we have 2D or a 3D problem.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
                <span class="c1"># Assemble all the points where we have constraints</span>
                <span class="n">X_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">))</span>
                <span class="n">Y_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">))</span>
                <span class="c1"># Get the unique values</span>
                <span class="n">unique_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">X_constr</span><span class="p">,</span> <span class="n">Y_constr</span><span class="p">)),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">X_unique</span> <span class="o">=</span> <span class="n">unique_values</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Y_unique</span> <span class="o">=</span> <span class="n">unique_values</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Get the additional RBF shape parameters</span>
                <span class="n">c_k</span><span class="p">,</span> <span class="n">d_k</span> <span class="o">=</span> <span class="n">add_constraint_collocations_2D</span><span class="p">(</span><span class="n">X_unique</span><span class="p">,</span> <span class="n">Y_unique</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_mM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="c1"># Concatenate them with the existing collocation points</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="n">c_k</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">d_k</span><span class="p">,</span> <span class="n">d_k</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="n">X_unique</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="n">Y_unique</span><span class="p">))</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span> <span class="c1"># 3D</span>
                <span class="c1"># Assemble all the points where we have constraints</span>
                <span class="n">X_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">))</span>
                <span class="n">Y_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">))</span>
                <span class="n">Z_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_D</span><span class="p">))</span>
                <span class="c1"># Get the unique values</span>
                <span class="n">unique_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">X_constr</span><span class="p">,</span> <span class="n">Y_constr</span><span class="p">,</span> <span class="n">Z_constr</span><span class="p">)),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">X_unique</span> <span class="o">=</span> <span class="n">unique_values</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Y_unique</span> <span class="o">=</span> <span class="n">unique_values</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">Z_unique</span> <span class="o">=</span> <span class="n">unique_values</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1"># Get the additional RBF shape parameters</span>
                <span class="n">c_k</span><span class="p">,</span> <span class="n">d_k</span> <span class="o">=</span> <span class="n">add_constraint_collocations_3D</span><span class="p">(</span><span class="n">X_unique</span><span class="p">,</span> <span class="n">Y_unique</span><span class="p">,</span> <span class="n">Z_unique</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_mM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="c1"># Concatenate them with the existing collocation points</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="n">c_k</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">d_k</span><span class="p">,</span> <span class="n">d_k</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="n">X_unique</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="n">Y_unique</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="n">Z_unique</span><span class="p">))</span>

        <span class="c1"># Summary output for the user</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_D</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; Dirichlet conditions assigned&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_N</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; Neumann conditions assigned&#39;</span><span class="p">)</span>

        <span class="k">return</span>


    <span class="c1"># 3.2 Scalar constraints</span>
    <span class="k">def</span> <span class="nf">vector_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DIR</span><span class="o">=</span><span class="p">[],</span> <span class="n">NEU</span><span class="o">=</span><span class="p">[],</span> <span class="n">DIV</span><span class="o">=</span><span class="p">[],</span> <span class="n">extra_RBF</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # This functions sets the boundary conditions for a laminar problem. The</span>
<span class="sd">        function must be run after the clustering was carried out.</span>

<span class="sd">        :type DIR: list of 1D numpy.ndarray</span>
<span class="sd">        :param DIR:</span>
<span class="sd">            This contains the info for the Dirichlet conditions.</span>
<span class="sd">            If the model is 2D, then this has [X_D, Y_D, c_D_X, c_D_Y].</span>
<span class="sd">            If the model is 3D, then this has [X_D, Y_D, Z_D, c_D_X, c_D_Y, c_D_Z].</span>

<span class="sd">            Here X_D, Y_D, Z_D are the coordinates of the poins where the value c_D_X,</span>
<span class="sd">            c_D_Y, c_D_Z is set in 2 or 3 dimensions.</span>

<span class="sd">        :type NEU: list of 1D numpy.ndarray</span>
<span class="sd">        :param NEU:</span>
<span class="sd">            This contains the info for the Neuman conditions.</span>
<span class="sd">            If the model is 2D, then this has [X_N, Y_N, n_x, n_y, c_N_X, c_N_Y].</span>
<span class="sd">            If the model is 3D, then this has [X_N, Y_N, Z_n, n_x, n_y, n_z, c_N_X, c_N_Y, c_N_Z].</span>

<span class="sd">            Here X_N, Y_N, Z_N are the coordinates of the poins where the value c_N_X,</span>
<span class="sd">            c_N_Y, c_N_Z is set for the directional derivative along the</span>
<span class="sd">            normal direction n_x,n_y,n_z</span>

<span class="sd">        :type DIV: list of 1D numpy.ndarray</span>
<span class="sd">        :param DIV:</span>
<span class="sd">            This contains the info for the Divergence free conditions.</span>
<span class="sd">            If the model is 2D, then this has [X_Div, Y_Div].</span>
<span class="sd">            If the model is 3D, then this has [X_Div, Y_Div, Z_Div].</span>

<span class="sd">            Here X_Div, Y_Div, Z_Div are the coordinates of the poins where the</span>
<span class="sd">            divergence-free condition is imposed.</span>

<span class="sd">        :type extra_RBF: bool</span>
<span class="sd">        :param extra_RBF: default=True</span>
<span class="sd">            This is a flag to put extra collocation points where a constraint is</span>
<span class="sd">            set. It can improve the solution of the linear system as constraints</span>
<span class="sd">            remove degrees of freedom</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check the input is correct</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">DIR</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;DIR must be a list&#39;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">NEU</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;NEU must be a list&#39;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">DIV</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;DIV must be a list&#39;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">extra_RBF</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">,</span> <span class="s1">&#39;extra_RBF must be a boolean&#39;</span>

        <span class="c1"># Check for Dirichlet conditions</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">DIR</span><span class="p">:</span> <span class="c1"># We have no Dirichlet conditions</span>
            <span class="c1"># We still assign empty arrays so that the assembly of the system is easier</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_D</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_D_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_D_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="c1"># In 3D, we must add the z terms</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Z_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_D_Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># We have Dirichlet conditions</span>
            <span class="c1"># Check if we have 2D or a 3D problem</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">DIR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_D</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_D_X</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_D_Y</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">DIR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span> <span class="c1"># 3D</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_D</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Z_D</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_D_X</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_D_Y</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_D_Z</span> <span class="o">=</span> <span class="n">DIR</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of Dirichlet conditions is wrong for type </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Check for Neumann conditions</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">NEU</span><span class="p">:</span> <span class="c1"># We have no Neumann conditions</span>
            <span class="c1"># We still assign empty arrays so that the assembly of the system is easier</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_N</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_N_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_N_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="c1"># In 3D, we must add the z terms</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_N_Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># We have Neumann conditions</span>
            <span class="c1"># Check if we have 2D or a 3D problem</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NEU</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span>  <span class="c1"># 2D</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NEU</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_N</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_N_X</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_N_Y</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">NEU</span><span class="p">)</span> <span class="o">==</span> <span class="mi">9</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span> <span class="c1"># 3D</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NEU</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_N</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_z</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_N_X</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_N_Y</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_N_Z</span> <span class="o">=</span> <span class="n">NEU</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of Neumann conditions is wrong for type </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Check for Divergence conditions</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">DIV</span><span class="p">:</span>
            <span class="c1"># We still assign empty arrays so that the assembly of the system is easier</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_Div</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># In 3D, we must add the z terms</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Z_Div</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Check if we have 2D or a 3D problem</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">DIV</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># this means 2D</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_Div</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DIV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span> <span class="o">=</span> <span class="n">DIV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span> <span class="o">=</span> <span class="n">DIV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_Div</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DIV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span> <span class="o">=</span> <span class="n">DIV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span> <span class="o">=</span> <span class="n">DIV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Z_Div</span> <span class="o">=</span> <span class="n">DIV</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Finally, we add the extra RBFs in the constraint points if desired</span>
        <span class="k">if</span> <span class="n">extra_RBF</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Check if we have 2D or a 3D problem.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
                <span class="c1"># Assemble all the points where we have constraints</span>
                <span class="n">X_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">))</span>
                <span class="n">Y_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">))</span>
                <span class="c1"># Get the unique values</span>
                <span class="n">unique_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">X_constr</span><span class="p">,</span> <span class="n">Y_constr</span><span class="p">)),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">X_unique</span> <span class="o">=</span> <span class="n">unique_values</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Y_unique</span> <span class="o">=</span> <span class="n">unique_values</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Get the additional RBF shape parameters</span>
                <span class="n">c_k</span><span class="p">,</span> <span class="n">d_k</span> <span class="o">=</span> <span class="n">add_constraint_collocations_2D</span><span class="p">(</span><span class="n">X_unique</span><span class="p">,</span> <span class="n">Y_unique</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_mM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="c1"># Concatenate them with the existing collocation points</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="n">c_k</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">d_k</span><span class="p">,</span> <span class="n">d_k</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="n">X_unique</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="n">Y_unique</span><span class="p">))</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span> <span class="c1"># 3D</span>
                <span class="c1"># Assemble all the points where we have constraints</span>
                <span class="n">X_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">))</span>
                <span class="n">Y_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">))</span>
                <span class="n">Z_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Z_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_Div</span><span class="p">))</span>
                <span class="c1"># Get the unique values</span>
                <span class="n">unique_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">X_constr</span><span class="p">,</span> <span class="n">Y_constr</span><span class="p">,</span> <span class="n">Z_constr</span><span class="p">)),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">X_unique</span> <span class="o">=</span> <span class="n">unique_values</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Y_unique</span> <span class="o">=</span> <span class="n">unique_values</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">Z_unique</span> <span class="o">=</span> <span class="n">unique_values</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1"># Get the additional RBF shape parameters</span>
                <span class="n">c_k</span><span class="p">,</span> <span class="n">d_k</span> <span class="o">=</span> <span class="n">add_constraint_collocations_3D</span><span class="p">(</span><span class="n">X_unique</span><span class="p">,</span> <span class="n">Y_unique</span><span class="p">,</span> <span class="n">Z_unique</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_mM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="c1"># Concatenate them with the existing collocation points</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="n">c_k</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">d_k</span><span class="p">,</span> <span class="n">d_k</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="n">X_unique</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="n">Y_unique</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="n">Z_unique</span><span class="p">))</span>

        <span class="c1"># Summary output for the user</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_D</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; D conditions assigned&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_N</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; N conditions assigned&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_Div</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; Div conditions assigned&#39;</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="c1"># 3.3 Plot the RBFs, this is just a visualization tool</span>
    <span class="k">def</span> <span class="nf">plot_RBFs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to check the spreading of the RBFs after the clustering.</span>
<span class="sd">        This function generates several plots. It produces no new variable in SPICY.</span>

<span class="sd">        :type l: int</span>
<span class="sd">        :param l:</span>
<span class="sd">            This defines the cluster level of RBF that will be visualized.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if it is 2D or 3D</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># We define the data that will be included</span>
                <span class="n">X_Plot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Clust_list</span><span class="o">==</span><span class="n">l</span><span class="p">)]</span>
                <span class="n">Y_Plot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Clust_list</span><span class="o">==</span><span class="n">l</span><span class="p">)]</span>
                <span class="n">d_K_Plot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_k</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Clust_list</span><span class="o">==</span><span class="n">l</span><span class="p">)]</span>

                <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">),</span> <span class="n">dpi</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
                <span class="c1"># First plot is the RBF distribution</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;RBF Collocation for l=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>

                <span class="c1"># Also show the data points</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;scalar&#39;</span><span class="p">:</span>
                     <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;laminar&#39;</span><span class="p">:</span>
                     <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">X_Plot</span><span class="p">),</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">circle1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="n">X_Plot</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y_Plot</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">d_K_Plot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                                          <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span><span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
                    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">circle1</span><span class="p">)</span>

                <span class="c1"># Also show the constraints if they are set</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span><span class="s1">&#39;ro&#39;</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span><span class="s1">&#39;bs&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;laminar&#39;</span><span class="p">:</span>
                     <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">,</span> <span class="s1">&#39;bd&#39;</span><span class="p">)</span>

                <span class="c1"># Second plot is the distribution of diameters:</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">d_K_Plot</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Basis index&#39;</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Diameter&#39;</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Distribution of diameters for L=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Problems in plotting. Set constraints and cluster!&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span> <span class="c1"># 3D</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># For now, we just show the distribution of diameters, as 3D sphere</span>
                <span class="c1"># visualizations are very difficult</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;RBF Collocation&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_k</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Basis index&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Diameter&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Distribution of diameters&quot;</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Problems in plotting. Set constraints and cluster!&#39;</span><span class="p">)</span>
        <span class="k">return</span>


    <span class="c1"># 4. Assembly A, B, b_1, b_2</span>

    <span class="c1"># We have two sorts of assemblies: poisson and regression.</span>
    <span class="c1"># poisson applies to the poisson solvers.</span>
    <span class="c1"># regression applies to scalar and laminar regression.</span>

    <span class="c1"># the poisson one includes the source terms on the r.h.s..</span>
    <span class="c1"># the regression one inlcudes a potential penalty of a divergence free flow.</span>

    <span class="c1"># 4.1. Poisson solver</span>
    <span class="k">def</span> <span class="nf">Assembly_Poisson</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_hb</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        This function assembly the matrices A, B, b_1, b_2 for the Poisson problem.</span>
<span class="sd">        These are eqs. (31a) - (31d) in the original paper (see also video tutorial 1 for more info)</span>

<span class="sd">        :type n_hb: int</span>
<span class="sd">        :param n_hb:</span>
<span class="sd">            When solving the Poisson equation, global basis elements such as polynomials or series</span>
<span class="sd">            expansions can be of great help. This is evident if one note that the eigenfunctions of</span>
<span class="sd">            the Laplace operator are harmonics.</span>
<span class="sd">            In a non-homogeneous problem, once could homogenize the basis. This will be proposed for the next relase</span>
<span class="sd">            (which will align with Manuel&#39;s paper). The idea is the following: if the homogeneization is well done and</span>
<span class="sd">            the basis is well chosen, then we do not need constraints for these extra terms of the basis.</span>

<span class="sd">            For the moment, we let the user introduce the number of extra_basis.</span>
<span class="sd">            These will be sine and cosine bases, which are orthogonal in [-1,1].</span>
<span class="sd">            In 1D, they are defined as : sines_n=np.sin(2*np.pi*(n)*x); cos_n=np.cos(np.pi/2*(2*n+1)*x)</span>
<span class="sd">            Given n_hb, we will have that the first n_hb are sines the last n_hb will be cosines.</span>
<span class="sd">            This defines the basis phi_h_n, with n an index from 0 to n_hb**4 in 2D.</span>

<span class="sd">            In 2D, assuming separation of variables, we will take phi_h_nm=phi_n(x)*phi_m(y).</span>
<span class="sd">            Similarly, in 3D will be phi_nmk=phi_n(x)*phi_m(y)*phi_k(z).</span>
<span class="sd">            For stability purposes, the largest tolerated value at the moment is 10!.</span>

<span class="sd">            For an homogeneous problem, the chosen basis needs no constraints.</span>

<span class="sd">            !!!!!!!!!!!!!!!#### this feature is currently under development #####!!!!!!!!!!!!!!!!</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">n_hb</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;Number of harmonic basis must be an integer&#39;</span>

        <span class="c1"># Assign the number of harmonic basis functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span> <span class="o">=</span> <span class="n">n_hb</span>
        <span class="c1"># Get the number of basis and points as we need them a couple of times</span>
        <span class="c1"># 2D and 3D have different bases</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_hb</span><span class="o">**</span><span class="mi">4</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_hb</span><span class="o">**</span><span class="mi">6</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">==</span><span class="s1">&#39;scalar&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
                <span class="c1"># Get the rescaling factor by normalizing the r.h.s. of the source terms</span>
                <span class="n">source_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">source_terms</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="o">-</span><span class="n">source_terms</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1">### Dirichlet constraints ###</span>
                <span class="c1"># Compute Phi on X_D</span>
                <span class="n">Matrix_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>

                <span class="c1">### Neumann constraints ###</span>
                <span class="c1"># Compute Phi_x on X_N</span>
                <span class="n">Matrix_Phi_2D_X_N_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_y on X_N</span>
                <span class="n">Matrix_Phi_2D_X_N_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_n on X_N</span>
                <span class="n">Matrix_D_N</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_N_der_x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span>\
                             <span class="n">Matrix_Phi_2D_X_N_der_y</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

                <span class="c1"># Assemble B and b_2, we also rescale b_2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Matrix_D</span><span class="p">,</span> <span class="n">Matrix_D_N</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_N</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span>

                <span class="c1"># Compute L on X_G</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_Laplacian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_Laplacian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>

                <span class="c1"># Assemble A and b_1, also rescale b_1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="nd">@L</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">source_terms</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span> <span class="c1"># 3D</span>
                <span class="c1"># get the rescaling factor by normalizing the r.h.s. of the source terms</span>
                <span class="n">source_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">source_terms</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="o">-</span><span class="n">source_terms</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1">### Dirichlet constraints ###</span>
                <span class="c1"># Compute Phi on X_D</span>
                <span class="n">Matrix_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_D</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>

                <span class="c1">### Neumann constraints ###</span>
                <span class="c1"># Compute Phi_x on X_N</span>
                <span class="n">Matrix_Phi_3D_X_N_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_y on X_N</span>
                <span class="n">Matrix_Phi_3D_X_N_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_z on X_N</span>
                <span class="n">Matrix_Phi_3D_X_N_der_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_z</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_z</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>

                <span class="c1"># Compute Phi_n on X_N</span>
                <span class="n">Matrix_D_N</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N_der_x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span>\
                             <span class="n">Matrix_Phi_3D_X_N_der_y</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span>\
                             <span class="n">Matrix_Phi_3D_X_N_der_z</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_z</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

                <span class="c1"># Assemble B and b_2, we also rescale b_2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Matrix_D</span><span class="p">,</span> <span class="n">Matrix_D_N</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_N</span><span class="p">))</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">rescale</span>

                <span class="c1"># Compute L on X_G</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_Laplacian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_Laplacian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>

                <span class="c1"># Assemble A and b_1, also rescale b_1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="nd">@L</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">source_terms</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Assembly_Poisson only build for the scalar function&#39;</span><span class="p">)</span>

        <span class="k">return</span>


    <span class="c1"># 4.2. Regression</span>
    <span class="k">def</span> <span class="nf">Assembly_Regression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_hb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">alpha_div</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function assembly the matrices A, B, C, D from the paper (see video tutorial 1).</span>

<span class="sd">        :type n_hb: int</span>
<span class="sd">        :param n_hb: int</span>

<span class="sd">            Also for a regression, the harmonic basis can improve the regression</span>
<span class="sd">            as they can model global trends which are similar to a low order</span>
<span class="sd">            polynomial. Furthermore, for homogenous problem, they automatically</span>
<span class="sd">            fulfill the boundary conditions.</span>

<span class="sd">           See the same entry in the function &#39;Assembly_Poisson&#39;</span>

<span class="sd">        :type alpha_div: float</span>
<span class="sd">        :param alpha_div:</span>
<span class="sd">            This enables a divergence free penalty in the entire flow field.</span>
<span class="sd">            The higher this parameter, the more SPICY penalizes errors in the divergence-free</span>
<span class="sd">            condition. This is particularly important to obtain good derivatives</span>
<span class="sd">            for the pressure computation.</span>

<span class="sd">         &quot;&quot;&quot;</span>
        <span class="c1"># Assign the number of harmonic basis functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span> <span class="o">=</span> <span class="n">n_hb</span>
        <span class="c1"># get the number of basis and points as we need them a couple of times</span>
        <span class="c1"># 2D and 3D have different bases</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_hb</span><span class="o">**</span><span class="mi">4</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_hb</span><span class="o">**</span><span class="mi">6</span>

        <span class="c1"># Scalar model:</span>
        <span class="c1"># Even though it is not included in the article, a scalar can also be</span>
        <span class="c1"># regressed in the same way with physical constraints</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;scalar&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
                <span class="c1"># define the rescaling factor which is done based on the maximum</span>
                <span class="c1"># absolute velocity that is available in u</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">))]</span>

                <span class="c1">### Dirichlet constraints ###</span>
                <span class="c1"># Compute Phi on X_D</span>
                <span class="n">Matrix_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>

                <span class="c1">### Neumann constraints ###</span>
                <span class="c1"># Compute Phi_x on X_N</span>
                <span class="n">Matrix_Phi_2D_X_N_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_y on X_N</span>
                <span class="n">Matrix_Phi_2D_X_N_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_n on X_N</span>
                <span class="n">Matrix_D_N</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_N_der_x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span>\
                             <span class="n">Matrix_Phi_2D_X_N_der_y</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

                <span class="c1"># Assemble B and b_2, we also rescale b_2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Matrix_D</span><span class="p">,</span> <span class="n">Matrix_D_N</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_N</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span>

                <span class="c1"># Compute Phi on X_G</span>
                <span class="n">Matrix_Phi_2D_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>

                <span class="c1"># Assemble A and b_1, we also rescale b_1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">Matrix_Phi_2D_X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_2D_X</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">Matrix_Phi_2D_X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span>
                <span class="c1"># define the rescaling factor which is done based on the maximum</span>
                <span class="c1"># absolute velocity that is available in u</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">))]</span>

                <span class="c1">### Dirichlet constraints ###</span>
                <span class="c1"># Compute Phi on X_D</span>
                <span class="n">Matrix_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_D</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>

                <span class="c1">### Neumann constraints ###</span>
                <span class="c1"># Compute Phi_x on X_N</span>
                <span class="n">Matrix_Phi_3D_X_N_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_y on X_N</span>
                <span class="n">Matrix_Phi_3D_X_N_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_z on X_N</span>
                <span class="n">Matrix_Phi_3D_X_N_der_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_n on X_N (equation (18))</span>
                <span class="n">Matrix_D_N</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N_der_x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span>\
                             <span class="n">Matrix_Phi_3D_X_N_der_y</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span>\
                             <span class="n">Matrix_Phi_3D_X_N_der_z</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_z</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

                <span class="c1"># Assemble B and b_2, we also rescale b_2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Matrix_D</span><span class="p">,</span> <span class="n">Matrix_D_N</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_N</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span>

                <span class="c1"># We compute Phi on all node points X</span>
                <span class="n">Matrix_Phi_3D_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Assemble A and b_1, we also rescale b_1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">Matrix_Phi_3D_X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_3D_X</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">Matrix_Phi_3D_X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span>

        <span class="c1"># Laminar model</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;laminar&#39;</span><span class="p">:</span>
            <span class="c1"># We need to check whether we are 2D or 3D laminar as this changes the assignment</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
                <span class="c1"># Define the rescaling factor which is done based on the maximum</span>
                <span class="c1"># absolute velocity that is available in u and v</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">))]</span>

                <span class="c1">### Divergence-free constraints ###</span>
                <span class="c1"># Compute Phi_x on X_Div</span>
                <span class="n">Matrix_Phi_2D_X_Div_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># compute the derivatives in y</span>
                <span class="n">Matrix_Phi_2D_X_Div_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Stack into the block structure of equation (15)</span>
                <span class="n">Matrix_D_Div</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Matrix_Phi_2D_X_Div_der_x</span><span class="p">,</span> <span class="n">Matrix_Phi_2D_X_Div_der_y</span><span class="p">))</span>

                <span class="c1">### Dirichlet constraints ###</span>
                <span class="c1"># Compute Phi on X_D</span>
                <span class="n">Matrix_Phi_2D_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Stack into the block structure of equation (16)</span>
                <span class="n">Matrix_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span>
                    <span class="p">[</span><span class="n">Matrix_Phi_2D_D</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">))],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">Matrix_Phi_2D_D</span><span class="p">]</span>
                    <span class="p">])</span>

                <span class="c1">### Neumann constraints ###</span>
                <span class="c1"># Compute Phi_x on X_N</span>
                <span class="n">Matrix_Phi_2D_X_N_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_y on X_N</span>
                <span class="n">Matrix_Phi_2D_X_N_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_n on X_N (equation (18))</span>
                <span class="n">Matrix_Phi_N</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_N_der_x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span>\
                               <span class="n">Matrix_Phi_2D_X_N_der_y</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="c1"># Stack into the block structure of equation (17)</span>
                <span class="n">Matrix_D_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span>
                    <span class="p">[</span><span class="n">Matrix_Phi_N</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">))],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">Matrix_Phi_N</span><span class="p">]</span>
                    <span class="p">])</span>

                <span class="c1"># Assemble B and b_2, we also rescale b_2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Matrix_D_Div</span><span class="p">,</span> <span class="n">Matrix_D</span><span class="p">,</span> <span class="n">Matrix_D_N</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_Div</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">c_D_X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_D_Y</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">c_N_X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_N_Y</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span>

                <span class="c1"># Compute Phi on X_G</span>
                <span class="n">Matrix_Phi_2D_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Stack Phi.T@Phi into the block structure of equation (10)</span>
                <span class="n">PhiT_dot_Phi</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_2D_X</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span>
                    <span class="p">[</span><span class="n">PhiT_dot_Phi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">))],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">PhiT_dot_Phi</span><span class="p">]</span>
                    <span class="p">])</span>
                <span class="c1"># compute and rescale b_1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Matrix_Phi_2D_X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">),</span> <span class="n">Matrix_Phi_2D_X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">)))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span>

                <span class="c1"># We check if alpha_div is None or 0 (some users might give 0)</span>
                <span class="c1"># if they are not experienced so we check for both</span>
                <span class="k">if</span> <span class="n">alpha_div</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">alpha_div</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Compute Phi_x on X_G</span>
                    <span class="n">Matrix_Phi_2D_X_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                        <span class="n">Phi_H_2D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                        <span class="n">Phi_RBF_2D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                        <span class="p">))</span>
                    <span class="c1"># Compute Phi_y on X_G</span>
                    <span class="n">Matrix_Phi_2D_X_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                        <span class="n">Phi_H_2D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                        <span class="n">Phi_RBF_2D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                        <span class="p">))</span>

                    <span class="c1"># Compute the individual matrix products between x, y and z</span>
                    <span class="c1"># For the diagonal</span>
                    <span class="n">PhiXT_dot_PhiX</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_der_x</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_2D_X_der_x</span><span class="p">)</span>
                    <span class="n">PhiYT_dot_PhiY</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_der_y</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_2D_X_der_y</span><span class="p">)</span>
                    <span class="c1"># For the off-diagonal elements</span>
                    <span class="n">PhiXT_dot_PhiY</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_der_x</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_2D_X_der_y</span><span class="p">)</span>

                    <span class="c1"># And we add them into the A-matrix</span>
                    <span class="c1"># Diagonal</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiXT_dot_PhiX</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiYT_dot_PhiY</span>
                    <span class="c1"># Upper off-diagonal elements</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiXT_dot_PhiY</span>
                    <span class="c1"># Lower off-diagonal elements</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiXT_dot_PhiY</span><span class="o">.</span><span class="n">T</span>


            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span> <span class="c1"># 3D</span>
                <span class="c1"># Define the rescaling factor which is done based on the maximum</span>
                <span class="c1"># absolute velocity that is available in u, v and w</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">))]</span>

                <span class="c1">### Divergence-free constraints ###</span>
                <span class="c1"># Compute Phi_x on X_Div</span>
                <span class="n">Matrix_Phi_3D_X_Div_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_Div</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_y on X_Div</span>
                <span class="n">Matrix_Phi_3D_X_Div_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_Div</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_z on X_Div</span>
                <span class="n">Matrix_Phi_3D_X_Div_der_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_z</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_z</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_Div</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_Div</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Stack into the block structure of equation (15)</span>
                <span class="n">Matrix_D_Div</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Matrix_Phi_3D_X_Div_der_x</span><span class="p">,</span>
                                          <span class="n">Matrix_Phi_3D_X_Div_der_y</span><span class="p">,</span>
                                          <span class="n">Matrix_Phi_3D_X_Div_der_z</span><span class="p">))</span>

                <span class="c1">### Dirichlet constraints ###</span>
                <span class="c1"># Compute Phi on X_D</span>
                <span class="n">Matrix_Phi_3D_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_D</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Stack into the block structure of equation (16)</span>
                <span class="n">Matrix_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span>
                    <span class="p">[</span><span class="n">Matrix_Phi_3D_D</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">))],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">Matrix_Phi_3D_D</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">))],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">Matrix_Phi_3D_D</span><span class="p">]</span>
                    <span class="p">])</span>

                <span class="c1">### Neumann constraints ###</span>
                <span class="c1"># Compute Phi_x on X_N</span>
                <span class="n">Matrix_Phi_3D_X_N_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_y on X_N</span>
                <span class="n">Matrix_Phi_3D_X_N_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_z on X_N</span>
                <span class="n">Matrix_Phi_3D_X_N_der_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_z</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_z</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_N</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute Phi_n on X_N (equation (18))</span>
                <span class="n">Matrix_Phi_N</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N_der_x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span>\
                               <span class="n">Matrix_Phi_3D_X_N_der_y</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span>\
                               <span class="n">Matrix_Phi_3D_X_N_der_z</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_z</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="c1"># Stack into the block structure of equation (17)</span>
                <span class="n">Matrix_D_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span>
                    <span class="p">[</span><span class="n">Matrix_Phi_N</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">))],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">Matrix_Phi_N</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">))],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">Matrix_Phi_N</span><span class="p">]</span>
                    <span class="p">])</span>

                <span class="c1"># Assemble B and b_2, we also rescale b_2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Matrix_D_Div</span><span class="p">,</span> <span class="n">Matrix_D</span><span class="p">,</span> <span class="n">Matrix_D_N</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_Div</span><span class="p">),</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">c_D_X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_D_Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_D_Z</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">c_N_X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_N_Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_N_Z</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span>

                <span class="c1"># Compute Phi on X_G</span>
                <span class="n">Matrix_Phi_3D_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Stack Phi.T@Phi into the block structure of equation (10)</span>
                <span class="n">PhiT_dot_Phi</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_3D_X</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span>
                    <span class="p">[</span><span class="n">PhiT_dot_Phi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">))],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">PhiT_dot_Phi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">))],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">)),</span> <span class="n">PhiT_dot_Phi</span><span class="p">]</span>
                    <span class="p">])</span>
                <span class="c1"># compute and rescale b_1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Matrix_Phi_3D_X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">),</span>
                                             <span class="n">Matrix_Phi_3D_X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">),</span>
                                             <span class="n">Matrix_Phi_3D_X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span>

                <span class="c1"># We check if alpha_div is None or 0 (some users might give 0)</span>
                <span class="c1"># if they are not experienced so we check for both</span>
                <span class="k">if</span> <span class="n">alpha_div</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">alpha_div</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Compute Phi_x on X_G</span>
                    <span class="n">Matrix_Phi_3D_X_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                        <span class="n">Phi_H_3D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                        <span class="n">Phi_RBF_3D_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                        <span class="p">))</span>
                    <span class="c1"># Compute Phi_y on X_G</span>
                    <span class="n">Matrix_Phi_3D_X_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                        <span class="n">Phi_H_3D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                        <span class="n">Phi_RBF_3D_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                        <span class="p">))</span>
                    <span class="c1"># Compute Phi_z on X_G</span>
                    <span class="n">Matrix_Phi_3D_X_der_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                        <span class="n">Phi_H_3D_z</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                        <span class="n">Phi_RBF_3D_z</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_G</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                        <span class="p">))</span>

                    <span class="c1"># Compute the individual matrix products between x, y and z</span>
                    <span class="c1"># For the diagonal</span>
                    <span class="n">PhiXT_dot_PhiX</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_der_x</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_3D_X_der_x</span><span class="p">)</span>
                    <span class="n">PhiYT_dot_PhiY</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_der_y</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_3D_X_der_y</span><span class="p">)</span>
                    <span class="n">PhiZT_dot_PhiZ</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_der_z</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_3D_X_der_z</span><span class="p">)</span>
                    <span class="c1"># For the off-diagonal elements</span>
                    <span class="n">PhiXT_dot_PhiY</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_der_x</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_3D_X_der_y</span><span class="p">)</span>
                    <span class="n">PhiXT_dot_PhiZ</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_der_x</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_3D_X_der_z</span><span class="p">)</span>
                    <span class="n">PhiYT_dot_PhiZ</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_der_y</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix_Phi_3D_X_der_z</span><span class="p">)</span>

                    <span class="c1"># And we add them into the A-matrix</span>
                    <span class="c1"># Diagonal</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiXT_dot_PhiX</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiYT_dot_PhiY</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiZT_dot_PhiZ</span>

                    <span class="c1"># Upper off-diagonal elements</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiXT_dot_PhiY</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiXT_dot_PhiZ</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiYT_dot_PhiZ</span>

                    <span class="c1"># Lower off-diagonal elements</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiXT_dot_PhiY</span><span class="o">.</span><span class="n">T</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiXT_dot_PhiZ</span><span class="o">.</span><span class="n">T</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_div</span><span class="o">*</span><span class="n">PhiYT_dot_PhiZ</span><span class="o">.</span><span class="n">T</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;RANSI&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;RANSI currently not implemented&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;RANSI&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;RANSI currently not implemented&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No regression could be performed, check that the model is correctly set&#39;</span><span class="p">)</span>
        <span class="k">return</span>


    <span class="c1"># 5 Solver using the Shur complement</span>
    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K_cond</span><span class="o">=</span><span class="mf">1e12</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function solves the constrained quadratic problem A, B, b_1, b_2.</span>
<span class="sd">        The method is universal for 2D/3D problems as well as laminar/Poisson problems.</span>

<span class="sd">        The input parameters are the class itself and the desired condition</span>
<span class="sd">        number of A which is fixed based on its largest and smallest eigenvalue</span>

<span class="sd">        The function assigns the weights &#39;w&#39; and the Lagrange multipliers</span>
<span class="sd">        Lambda to the class. The weights are computed for the min/max scaled problem,</span>
<span class="sd">        i.e. the right hand-side of the linear system is normalized. The assigned</span>
<span class="sd">        weights are rescaled by self.scale_U to get the real, physical quantities</span>

<span class="sd">        K_cond : float, default 1e12</span>
<span class="sd">            This is the regularization parameter. It fixes the condition number (see Video 1)</span>
<span class="sd">            The estimation is based such that the regularize matrix has the condition</span>
<span class="sd">            number k_cond. For this, we compute the max and the min eigenvalue.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Two options:</span>
        <span class="c1"># 1.: We do not have constraints, then we only need to solve A*w = b_1</span>
        <span class="c1"># 2.: We have constraints, then B and b_2 are not empty, and we go for Schur complements</span>

        <span class="c1"># We follow the 9 steps from Algorithm 1 in Sperotto et al. (2022)</span>

        <span class="c1"># Step 1: Compute A, B, b1, b2</span>
        <span class="c1"># Already carried out in the Assembly_Regression function</span>

        <span class="c1"># No constraints (this is not mentioned in the original paper)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solving without constraints&#39;</span><span class="p">)</span>

            <span class="c1"># Step 2 + 3: Factorize the Matrix A</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_factorize_A</span><span class="p">(</span><span class="n">K_cond</span><span class="o">=</span><span class="n">K_cond</span><span class="p">)</span>

            <span class="c1"># Step 9: Solve for w and append into the list of weights</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L_A</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_U</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Weights computed&#39;</span><span class="p">)</span>

        <span class="c1"># Constraints</span>
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_2</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solving without constraints&#39;</span><span class="p">)</span>

            <span class="c1"># Step 2 + 3: Factorize the Matrix A</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_factorize_A</span><span class="p">(</span><span class="n">K_cond</span><span class="o">=</span><span class="n">K_cond</span><span class="p">)</span>

            <span class="c1"># Step 4: Solve for R. This is different to the article because of numerical stability</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L_A</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Step 5 + 6: Factorize the Matrix A</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_factorize_M</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">K_cond</span><span class="o">=</span><span class="n">K_cond</span><span class="p">)</span>

            <span class="c1"># Step 7 + 8: Compute b_2_star, solve the system for lambda</span>
            <span class="n">b_2_star</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_U</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lambdas</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L_M</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">b_2_star</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># print(&#39;Lambdas computed&#39;)</span>

            <span class="c1"># Step 9: Solve for w and append into the list of weights</span>
            <span class="n">b_1_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_U</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambdas</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L_A</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">b_1_star</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Weights and Lambdas computed&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># This should never be reached during regular use, it is useful for debugging</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;b_1 or B is empty while the other is not, check your constraints!&#39;</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_factorize_A</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K_cond</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for the Cholesky factorization of A with regularization</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        K_cond : float</span>
<span class="sd">            Desired conditioning number for the matrix A. This is approximated from the largest eigenvalue.</span>
<span class="sd">            See video tutorials for more info</span>

<span class="sd">        Assigns</span>
<span class="sd">        -------</span>
<span class="sd">        L_A : 2D numpy.ndarray</span>
<span class="sd">            Cholesky factorization of A, overwritten onto A.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">L_A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Step 2: Regularize the matrix A</span>
            <span class="n">lambda_A</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_U</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">return_eigenvectors</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Largest eigenvalue</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">lambda_A</span> <span class="o">-</span> <span class="n">K_cond</span> <span class="o">*</span> <span class="mf">2.2e-16</span><span class="p">)</span> <span class="o">/</span> <span class="n">K_cond</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_U</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Matrix A regularized&#39;</span><span class="p">)</span>

            <span class="c1"># Step 3: Cholesky Decomposition of A</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L_A</span><span class="p">,</span> <span class="n">low</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Matrix A factorized&#39;</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_factorize_M</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">K_cond</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for the Cholesky factorization of M. Computes the matrix M based on the given N</span>
<span class="sd">        and the constraint matrix B. Initial try is without regularization. If it fails, the</span>
<span class="sd">        normal regularization is applied.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        R : 2D numpy.ndarray</span>
<span class="sd">            Intermediate quantity defined as L_A^-1 @ B (see equation 37 of Sperotto et al. (2022)).</span>

<span class="sd">        K_cond : float</span>
<span class="sd">            Desired conditioning number for the matrix M. This is approximated from the largest eigenvalue.</span>
<span class="sd">            See video tutorials for more info</span>

<span class="sd">        Assigns</span>
<span class="sd">        -------</span>
<span class="sd">        L_M : 2D numpy.ndarray</span>
<span class="sd">            Cholesky factorization of M, overwritten onto M.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Step 4: prepare M</span>
        <span class="c1"># This computes R.T @ R. We multiply with B because of numerical stability</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span>

        <span class="c1"># Step 5: Regularize the matrix M</span>
        <span class="n">lambda_M</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">return_eigenvectors</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Largest eigenvalue</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">lambda_M</span> <span class="o">-</span> <span class="n">K_cond</span> <span class="o">*</span> <span class="mf">2.2e-16</span><span class="p">)</span> <span class="o">/</span> <span class="n">K_cond</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">M</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Matrix M regularized&#39;</span><span class="p">)</span>

        <span class="c1"># Step 6: Cholesky Decomposition of A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L_M</span><span class="p">,</span> <span class="n">low</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Matrix M factorized&#39;</span><span class="p">)</span>

        <span class="k">return</span>


    <span class="c1"># 6. Evaluate solution on arbitrary grid</span>

    <span class="c1"># Here is a function to compute the solution on an arbitrary set of points</span>
    <span class="c1"># X_G, Y_G. We take w, lam from the solution, X_C, Y_C, c_k from the clustering.</span>
    <span class="k">def</span> <span class="nf">Get_Sol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function evaluates the solution of the linear system on an arbitrary</span>
<span class="sd">        set of points on the grid.</span>

<span class="sd">        :type K_cond: list</span>
<span class="sd">        :param grid:</span>
<span class="sd">            Contains the points at which the source term is evaluated</span>
<span class="sd">            If the model is 2D, then this has [X_P, Y_P].</span>
<span class="sd">            If the model is 3D, then this has [X_P, Y_P, Z_P].</span>

<span class="sd">        :return: U_sol, V_sol, W_sol.</span>
<span class="sd">            Depending on model=&#39;scalar/laminar&#39; and type=&#39;2D/3D&#39;</span>
<span class="sd">            If scalar, the solution is only U_sol.</span>
<span class="sd">            If laminar and 2D, the solution is U_sol, V_sol</span>
<span class="sd">            If laminar and 3D, the solution is U_sol, V_sol and W_sol</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check the input is correct</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;grid must be a list&#39;</span>

        <span class="c1"># Check if the grid has the correct length</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
            <span class="c1"># Assign the grid</span>
            <span class="n">X_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Y_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Check what model type we have</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;scalar&#39;</span><span class="p">:</span> <span class="c1"># Scalar</span>
                <span class="c1"># Evaluate Phi on the grid X_P</span>
                <span class="n">Phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute U on the new grid</span>
                <span class="n">U_sol</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">U_sol</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;laminar&#39;</span><span class="p">:</span> <span class="c1"># Laminar</span>
                <span class="c1"># Evaluate Phi on the grid X_P</span>
                <span class="n">Phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>

                <span class="c1"># Compute the individual components</span>
                <span class="n">U_sol</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>
                <span class="n">V_sol</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>

                <span class="k">return</span> <span class="n">U_sol</span><span class="p">,</span> <span class="n">V_sol</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span> <span class="c1"># 3D</span>
            <span class="c1"># Assign the grid</span>
            <span class="n">X_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Y_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">Z_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># Check what model type we have</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;scalar&#39;</span><span class="p">:</span> <span class="c1"># Scalar</span>
                <span class="c1"># Evaluate Phi on the grid X_P</span>
                <span class="n">Phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute U on the new grid</span>
                <span class="n">U_sol</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">U_sol</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;laminar&#39;</span><span class="p">:</span> <span class="c1"># Laminar</span>
                <span class="c1"># Evaluate Phi on the grid X_P</span>
                <span class="n">Phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute the individual components</span>
                <span class="n">U_sol</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>
                <span class="n">V_sol</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>
                <span class="n">W_sol</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>

                <span class="k">return</span> <span class="n">U_sol</span><span class="p">,</span> <span class="n">V_sol</span><span class="p">,</span> <span class="n">W_sol</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of Grid is invalid for Type &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Get_first_Derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function evaluates the first derivative of the solution of the</span>
<span class="sd">        linear system on an arbitrary set of points on the grid.</span>

<span class="sd">        :type grid: list</span>
<span class="sd">        :param grid:</span>
<span class="sd">            Contains the points at which the source term is evaluated</span>
<span class="sd">            If the model is 2D, then this has [X_P, Y_P].</span>
<span class="sd">            If the model is 3D, then this has [X_P, Y_P, Z_P].</span>

<span class="sd">        :return: dUdX, dUdY, dUdX, dVdX, dVdY, dVdX, dWdX, dWdY, dWdX.</span>
<span class="sd">            Depending on model = &#39;scalar/laminar&#39; and type = &#39;2D/3D&#39;</span>
<span class="sd">            If scalar and 2D, the output is dUdX, dUdY</span>
<span class="sd">            If scalar and 3D, the output is dUdX, dUdY, dUdZ</span>
<span class="sd">            If laminar and 2D, the solution is dUdx, dUdY, dVdX, dVdY</span>
<span class="sd">            If laminar and 3D, the solution is dUdx, dUdY, dUdX, dVdX, dVdY, dVdX, dWdX, dWdY, dWdX</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check the input is correct</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;grid must be a list&#39;</span>

        <span class="c1"># Check if the grid has the correct length</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
            <span class="c1"># Assign the grid</span>
            <span class="n">X_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Y_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Check what model type we have</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;scalar&#39;</span><span class="p">:</span> <span class="c1"># Scalar</span>
                <span class="c1"># Evaluate Phi_x on the grid X_P, Y_P</span>
                <span class="n">Phi_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_x</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_x</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Evaluate Phi_y on the grid X_P,Y_P</span>
                <span class="n">Phi_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_y</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_y</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute dudx and dudy on the new grid</span>
                <span class="n">dUdX</span> <span class="o">=</span> <span class="n">Phi_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
                <span class="n">dUdY</span> <span class="o">=</span> <span class="n">Phi_y</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">dUdX</span><span class="p">,</span> <span class="n">dUdY</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;laminar&#39;</span><span class="p">:</span> <span class="c1"># Laminar</span>
                <span class="c1"># We do it in 2 blocks: first all derivatives in x</span>
                <span class="c1"># Evaluate Phi on the grid X_P, Y_P</span>
                <span class="n">Phi_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_x</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_x</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute dudx and dvdx on the new grid</span>
                <span class="n">dUdX</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>
                <span class="n">dVdX</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>

                <span class="c1"># Then we do it again for the derivatives of y.</span>
                <span class="c1"># Note however, that we re-use the same variables Phi_deriv</span>
                <span class="c1"># to limit the memory usage. This is pretty much copy-paste.</span>
                <span class="n">Phi_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_2D_y</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_2D_y</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute dudy and dvdy on the new grid</span>
                <span class="n">dUdY</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>
                <span class="n">dVdY</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>

                <span class="k">return</span> <span class="n">dUdX</span><span class="p">,</span> <span class="n">dUdY</span><span class="p">,</span> <span class="n">dVdX</span><span class="p">,</span> <span class="n">dVdY</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span> <span class="c1"># 3D</span>
            <span class="c1"># Assign the grid</span>
            <span class="n">X_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Y_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">Z_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># Check what model type we have</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;scalar&#39;</span><span class="p">:</span> <span class="c1"># Scalar</span>
                <span class="c1"># Evaluate Phi_x on the grid X_P, Y_P, Z_P for dudx</span>
                <span class="n">Phi_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_x</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_x</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute dudx on the new grid</span>
                <span class="n">dUdX</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
                <span class="c1"># Now again for the derivative on dudy</span>
                <span class="n">Phi_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_y</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_y</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute dudx on the new grid</span>
                <span class="n">dUdY</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
                <span class="c1"># Now again for the derivative on dudz</span>
                <span class="n">Phi_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                    <span class="n">Phi_H_3D_z</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                    <span class="n">Phi_RBF_3D_z</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                    <span class="p">))</span>
                <span class="c1"># Compute dudx on the new grid</span>
                <span class="n">dUdZ</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">dUdX</span><span class="p">,</span> <span class="n">dUdY</span><span class="p">,</span> <span class="n">dUdZ</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;laminar&#39;</span><span class="p">:</span> <span class="c1"># Laminar</span>
                <span class="c1"># We do it in 3 blocks: first all derivatives in x</span>
                <span class="c1"># Evaluate Phi on the grid X_P, Y_P, Z_P</span>
                <span class="n">Phi_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                     <span class="n">Phi_H_3D_x</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                     <span class="n">Phi_RBF_3D_x</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                     <span class="p">))</span>
                <span class="c1"># Compute dudx, dvdx, dwdx on the new grid</span>
                <span class="n">dUdX</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>
                <span class="n">dVdX</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>
                <span class="n">dWdX</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>

                <span class="c1"># Then we do it again for the derivatives of y.</span>
                <span class="c1"># Note however, that we re-use the same variables Phi_deriv</span>
                <span class="c1"># to limit the memory usage. This is pretty much copy-paste.</span>
                <span class="n">Phi_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                     <span class="n">Phi_H_3D_y</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                     <span class="n">Phi_RBF_3D_y</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                     <span class="p">))</span>
                <span class="c1"># Compute dudy, dvdy, dwdy on the new grid</span>
                <span class="n">dUdY</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>
                <span class="n">dVdY</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>
                <span class="n">dWdY</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>

                <span class="c1"># All derivatives along z -------------------------</span>
                <span class="n">Phi_deriv</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                     <span class="n">Phi_H_3D_z</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                     <span class="n">Phi_RBF_3D_z</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                     <span class="p">))</span>
                <span class="c1"># Compute dudz, dvdz, dwdz on the new grid</span>
                <span class="n">dUdZ</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>
                <span class="n">dVdZ</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>
                <span class="n">dWdZ</span> <span class="o">=</span> <span class="n">Phi_deriv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">])</span>

                <span class="k">return</span> <span class="n">dUdX</span><span class="p">,</span> <span class="n">dUdY</span><span class="p">,</span> <span class="n">dUdZ</span><span class="p">,</span> <span class="n">dVdX</span><span class="p">,</span> <span class="n">dVdY</span><span class="p">,</span> <span class="n">dVdZ</span><span class="p">,</span> <span class="n">dWdX</span><span class="p">,</span> <span class="n">dWdY</span><span class="p">,</span> <span class="n">dWdZ</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of Grid is invalid for Type &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>


    <span class="c1"># Here is a function to evaluate the forcing term on the grid points that are</span>
    <span class="c1"># used for the pressure</span>
    <span class="k">def</span> <span class="nf">Evaluate_Source_Term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function evaluates the source term on the right hand side of</span>
<span class="sd">        equation (21) in the paper (see video tutorial 1 for more info)</span>

<span class="sd">        :type grid: list</span>
<span class="sd">        :param grid:</span>
<span class="sd">            Contains the points at which the source term is evaluated</span>
<span class="sd">            If the model is 2D, then this has [X_P, Y_P].</span>
<span class="sd">            If the model is 3D, then this has [X_P, Y_P, Z_P].</span>

<span class="sd">        :type rho: float</span>
<span class="sd">        :param rho:</span>
<span class="sd">           Density of the fluid.</span>

<span class="sd">        :return: source_term</span>
<span class="sd">            R.h.s. of equation (21).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check the input is correct</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;grid must be a list&#39;</span>

        <span class="c1"># check whether it is 2D or 3D</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
            <span class="c1"># assign the grid points in X and Y</span>
            <span class="n">X_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Y_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">W_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">]</span>
            <span class="n">W_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:]</span>

            <span class="c1"># We compute Phi_x on X_P</span>
            <span class="n">Matrix_Phi_2D_X_P_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_2D_x</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_2D_x</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># We compute the derivatives of the velocity field along x</span>
            <span class="n">dUdX</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_P_der_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">dVdX</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_P_der_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>

            <span class="c1"># We compute Phi_y on X_P</span>
            <span class="n">Matrix_Phi_2D_X_P_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_2D_y</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_2D_y</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># We compute the derivatives of the velocity field along y</span>
            <span class="n">dUdY</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_P_der_y</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">dVdY</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_P_der_y</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>

            <span class="c1">#forcing term is evaluated</span>
            <span class="n">source_term</span> <span class="o">=</span> <span class="o">-</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">dUdX</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">dUdY</span><span class="o">*</span><span class="n">dVdX</span><span class="o">+</span><span class="n">dVdY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span>
            <span class="c1"># assign the grid points in X and Y</span>
            <span class="n">X_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Y_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">Z_P</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">W_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">]</span>
            <span class="n">W_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">]</span>
            <span class="n">W_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">]</span>

            <span class="c1"># We compute Phi_x on X_P</span>
            <span class="n">Matrix_Phi_3D_X_P_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_3D_x</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_3D_x</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># We compute the derivatives of the velocity field along x</span>
            <span class="n">dUdX</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_P_der_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">dVdX</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_P_der_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>
            <span class="n">dWdX</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_P_der_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_w</span><span class="p">)</span>

            <span class="c1"># We compute Phi_y on X_P</span>
            <span class="n">Matrix_Phi_3D_X_P_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_3D_y</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_3D_y</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># We compute the derivatives of the velocity field along y</span>
            <span class="n">dUdY</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_P_der_y</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">dVdY</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_P_der_y</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>
            <span class="n">dWdY</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_P_der_y</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_w</span><span class="p">)</span>

            <span class="c1"># We compute Phi_z on X_P</span>
            <span class="n">Matrix_Phi_3D_X_P_der_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_3D_z</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_3D_z</span><span class="p">(</span><span class="n">X_P</span><span class="p">,</span> <span class="n">Y_P</span><span class="p">,</span> <span class="n">Z_P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># We compute the derivatives of the velocity field along y</span>
            <span class="n">dUdZ</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_P_der_z</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">dVdZ</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_P_der_z</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>
            <span class="n">dWdZ</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_P_der_z</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_w</span><span class="p">)</span>

            <span class="c1">#forcing term is evaluated</span>
            <span class="n">source_term</span> <span class="o">=</span> <span class="o">-</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">dUdX</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">dVdY</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">dWdZ</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dUdY</span><span class="o">*</span><span class="n">dVdX</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dUdZ</span><span class="o">*</span><span class="n">dWdX</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dVdZ</span><span class="o">*</span><span class="n">dWdY</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of Grid is invalid for Type &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">source_term</span>


    <span class="k">def</span> <span class="nf">Get_Pressure_Neumann</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function evaluates the Neumann boundary conditions for the pressure</span>
<span class="sd">        integration in equation (29) from the original paper (see video tutorial 1 for more info)</span>

<span class="sd">        :type grid: list</span>
<span class="sd">        :param grid:</span>
<span class="sd">            Contains the points at which the Neumann constraint is evaluated.</span>
<span class="sd">            If the model is 2D, then this has [X_P, Y_P].</span>
<span class="sd">            If the model is 3D, then this has [X_P, Y_P, Z_P].</span>

<span class="sd">        :type normals: list</span>
<span class="sd">        :param normals:</span>
<span class="sd">            Contains normals of the points at which the Neumann constraint is evaluated.</span>
<span class="sd">            If the model is 2D, then this has [n_x, n_y].</span>
<span class="sd">            If the model is 3D, then this has [n_x, n_y, n_z].</span>

<span class="sd">        :type rho: float</span>
<span class="sd">        :param rho:</span>
<span class="sd">            Density of the fluid.</span>

<span class="sd">        :type mu: float</span>
<span class="sd">        :param mu:</span>
<span class="sd">            Dynamic viscosity of the fluid.</span>

<span class="sd">        :return: P_neu</span>
<span class="sd">            Normal pressure in equation (29).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check the input is correct</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;grid must be a list&#39;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">normals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;normals must be a list&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">normals</span><span class="p">),</span> <span class="s1">&#39;Length of grid must be equal to the length of normals&#39;</span>
        <span class="c1"># Check if we have 2D or 3D data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;2D&#39;</span><span class="p">:</span> <span class="c1"># 2D</span>
            <span class="c1"># Assign the grid</span>
            <span class="n">X_N</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Y_N</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Assign the normals</span>
            <span class="n">n_x</span> <span class="o">=</span> <span class="n">normals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_y</span> <span class="o">=</span> <span class="n">normals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Assign the weights</span>
            <span class="n">W_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">]</span>
            <span class="n">W_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:]</span>
            <span class="c1"># Compute the matrix Phi_x on X_N</span>
            <span class="n">Matrix_Phi_2D_X_N_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_2D_x</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_2D_x</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># Compute the derivatives along x</span>
            <span class="n">dUdX</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_N_der_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">dVdX</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_N_der_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>

            <span class="c1"># Compute the matrix Phi_y on X_N</span>
            <span class="n">Matrix_Phi_2D_X_N_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_2D_y</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_2D_y</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># Compute the derivatives along y</span>
            <span class="n">dUdY</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_N_der_y</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">dVdY</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_N_der_y</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>

            <span class="c1"># Compute the matrix Phi on X_N</span>
            <span class="n">Matrix_Phi_2D_X_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_2D</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_2D</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># Compute the velocities</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_N</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">Matrix_Phi_2D_X_N</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>

            <span class="c1"># Compute the Laplacian on X_N</span>
            <span class="n">L_X_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_2D_Laplacian</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_2D_Laplacian</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># Compute the Laplacian for U and V</span>
            <span class="n">L_U</span> <span class="o">=</span> <span class="n">L_X_N</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">L_V</span> <span class="o">=</span> <span class="n">L_X_N</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>

            <span class="c1"># Compute the pressure normals</span>
            <span class="n">P_N_x</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="n">L_U</span> <span class="o">-</span> <span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="n">dUdX</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">dUdY</span><span class="p">)</span>
            <span class="n">P_N_y</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="n">L_V</span> <span class="o">-</span> <span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="n">dVdX</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">dVdY</span><span class="p">)</span>

            <span class="c1"># Multiply with the normals to get the projected pressure</span>
            <span class="n">P_Neu</span> <span class="o">=</span> <span class="n">P_N_x</span> <span class="o">*</span> <span class="n">n_x</span> <span class="o">+</span> <span class="n">P_N_y</span> <span class="o">*</span> <span class="n">n_y</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span>
            <span class="c1"># Assign the grid</span>
            <span class="n">X_N</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Y_N</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">Z_N</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># Assign the normals</span>
            <span class="n">n_x</span> <span class="o">=</span> <span class="n">normals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_y</span> <span class="o">=</span> <span class="n">normals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n_z</span> <span class="o">=</span> <span class="n">normals</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># Assign the weights</span>
            <span class="n">W_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">]</span>
            <span class="n">W_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">]</span>
            <span class="n">W_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_b</span><span class="p">]</span>

            <span class="c1"># Compute the matrix Phi_x on X_N</span>
            <span class="n">Matrix_Phi_3D_X_N_der_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_3D_x</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_3D_x</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># Compute the derivatives along x</span>
            <span class="n">dUdX</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N_der_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">dVdX</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N_der_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>
            <span class="n">dWdX</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N_der_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_w</span><span class="p">)</span>

            <span class="c1"># Compute the matrix Phi_y on X_N</span>
            <span class="n">Matrix_Phi_3D_X_N_der_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_3D_y</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_3D_y</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># Compute the derivatives along y</span>
            <span class="n">dUdY</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N_der_y</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">dVdY</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N_der_y</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>
            <span class="n">dWdY</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N_der_y</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_w</span><span class="p">)</span>

            <span class="c1"># Compute the matrix Phi_z on X_N</span>
            <span class="n">Matrix_Phi_3D_X_N_der_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_3D_z</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_3D_z</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># Compute the derivatives along y</span>
            <span class="n">dUdZ</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N_der_z</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">dVdZ</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N_der_z</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>
            <span class="n">dWdZ</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N_der_z</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_w</span><span class="p">)</span>

            <span class="c1"># Compute the matrix Phi on X_N</span>
            <span class="n">Matrix_Phi_3D_X_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_3D</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_3D</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># Compute the velocities</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">Matrix_Phi_3D_X_N</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_w</span><span class="p">)</span>

            <span class="c1"># Compute the Laplacian on X_N</span>
            <span class="n">L_X_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
                <span class="n">Phi_H_3D_Laplacian</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hb</span><span class="p">),</span>
                <span class="n">Phi_RBF_3D_Laplacian</span><span class="p">(</span><span class="n">X_N</span><span class="p">,</span> <span class="n">Y_N</span><span class="p">,</span> <span class="n">Z_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="p">))</span>
            <span class="c1"># Compute the Laplacian for U and V</span>
            <span class="n">L_U</span> <span class="o">=</span> <span class="n">L_X_N</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_u</span><span class="p">)</span>
            <span class="n">L_V</span> <span class="o">=</span> <span class="n">L_X_N</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_v</span><span class="p">)</span>
            <span class="n">L_W</span> <span class="o">=</span> <span class="n">L_X_N</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_w</span><span class="p">)</span>

            <span class="c1"># Compute the pressure normals</span>
            <span class="n">P_N_x</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="n">L_U</span> <span class="o">-</span> <span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="n">dUdX</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">dUdY</span> <span class="o">+</span> <span class="n">W</span><span class="o">*</span><span class="n">dUdZ</span><span class="p">)</span>
            <span class="n">P_N_y</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="n">L_V</span> <span class="o">-</span> <span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="n">dVdX</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">dVdY</span> <span class="o">+</span> <span class="n">W</span><span class="o">*</span><span class="n">dVdZ</span><span class="p">)</span>
            <span class="n">P_N_z</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="n">L_W</span> <span class="o">-</span> <span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="n">dWdX</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">dWdY</span> <span class="o">+</span> <span class="n">W</span><span class="o">*</span><span class="n">dWdZ</span><span class="p">)</span>

            <span class="c1"># Multiply with the normals to get the projected pressure</span>
            <span class="n">P_Neu</span> <span class="o">=</span> <span class="n">P_N_x</span> <span class="o">*</span> <span class="n">n_x</span> <span class="o">+</span> <span class="n">P_N_y</span> <span class="o">*</span> <span class="n">n_y</span> <span class="o">+</span> <span class="n">P_N_z</span> <span class="o">*</span> <span class="n">n_z</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of Grid is invalid for Type &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">P_Neu</span></div>



<span class="c1"># =============================================================================</span>
<span class="c1">#  Utilities functions</span>
<span class="c1">#  These functions are not needed/called by the user. They are simply helper</span>
<span class="c1">#  functions required to assemble and solve the linear systems. In the current</span>
<span class="c1">#  release of SPICY, these are:</span>
<span class="c1">#  - RBF functions and their derivatives in 2D/3D</span>
<span class="c1">#  - Harmonics functions and their derivatives in 2D/3D</span>
<span class="c1">#  - Adding collocation points in the constraints</span>
<span class="c1"># =============================================================================</span>



<span class="c1"># =============================================================================</span>
<span class="c1">#  RBF functions in 2D</span>
<span class="c1">#  Includes: Phi_RBF_2D, Phi_RBF_2D_x, Phi_RBF_2D_y, Phi_RBF_2D_Laplacian</span>
<span class="c1"># =============================================================================</span>

<span class="k">def</span> <span class="nf">Phi_RBF_2D</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span> <span class="n">Y_G</span><span class="p">,</span> <span class="n">X_C</span><span class="p">,</span> <span class="n">Y_C</span><span class="p">,</span> <span class="n">c_k</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the basis matrix at the points (X_G,Y_G) from RBFs at the collocation points</span>
<span class="sd">    at (X_C,Y_C), having shape factors c_k. The output is a matrix of side (n_p) x (n_c).</span>
<span class="sd">    The basis can be &#39;c4&#39; or &#39;gauss&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This is the contribution of the RBF part</span>
    <span class="n">n_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_C</span><span class="p">);</span> <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="n">Phi_RBF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_b</span><span class="p">))</span>

    <span class="c1"># What comes next depends on the type of chosen RBF</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Compute the Gaussian</span>
            <span class="n">gaussian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Phi_RBF</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaussian</span>

    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Get distance</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Compute Phi</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">d</span><span class="o">/</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">d</span><span class="o">/</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">5</span>
            <span class="c1"># Compact support</span>
            <span class="n">phi</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Phi_RBF</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span>

    <span class="c1"># Return the matrix</span>
    <span class="k">return</span> <span class="n">Phi_RBF</span>


<span class="k">def</span> <span class="nf">Phi_RBF_2D_x</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span> <span class="n">Y_G</span><span class="p">,</span> <span class="n">X_C</span><span class="p">,</span> <span class="n">Y_C</span><span class="p">,</span> <span class="n">c_k</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the derivative along x of the basis matrix at the points (X_G,Y_G) from</span>
<span class="sd">    RBFs at the collocation points at (X_C,Y_C), having shape factors c_k. The</span>
<span class="sd">    output is a matrix of side (n_p) x (n_c). The basis can be &#39;c4&#39; or &#39;gauss&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># number of bases (n_b) and points (n_p)</span>
    <span class="n">n_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_C</span><span class="p">);</span> <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># Initialize the matrix</span>
    <span class="n">Phi_RBF_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_b</span><span class="p">))</span>

    <span class="c1"># What comes next depends on the type of chosen RBF</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Compute the Gaussian</span>
            <span class="n">gaussian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="c1"># Multiply with inner term and assemble into matrix</span>
            <span class="n">Phi_RBF_x</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">*</span><span class="n">gaussian</span>

    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Get distance</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Compute derivative along x</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">10</span><span class="o">/</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="c1"># Compact support</span>
            <span class="n">phi</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Phi_RBF_x</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span>

    <span class="c1"># Return the matrix</span>
    <span class="k">return</span> <span class="n">Phi_RBF_x</span>


<span class="k">def</span> <span class="nf">Phi_RBF_2D_y</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span> <span class="n">Y_G</span><span class="p">,</span> <span class="n">X_C</span><span class="p">,</span> <span class="n">Y_C</span><span class="p">,</span> <span class="n">c_k</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the derivative along y of the basis matrix at the points (X_G,Y_G) from</span>
<span class="sd">    RBFs at the collocation points at (X_C,Y_C), having shape factors c_k. The</span>
<span class="sd">    output is a matrix of side (n_p) x (n_c). The basis can be &#39;c4&#39; or &#39;gauss&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># number of bases (n_b) and points (n_p)</span>
    <span class="n">n_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_C</span><span class="p">);</span> <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># Initialize the matrix</span>
    <span class="n">Phi_RBF_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_b</span><span class="p">))</span>

    <span class="c1"># What comes next depends on the type of chosen RBF</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Compute the Gaussian</span>
            <span class="n">gaussian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="c1"># Multiply with inner term and assemble into matrix</span>
            <span class="n">Phi_RBF_y</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">*</span><span class="n">gaussian</span>

    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Get distance</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Compute derivative along y</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">10</span><span class="o">/</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="c1"># Compact support</span>
            <span class="n">phi</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Phi_RBF_y</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span>

    <span class="c1"># Return the matrix</span>
    <span class="k">return</span> <span class="n">Phi_RBF_y</span>


<span class="k">def</span> <span class="nf">Phi_RBF_2D_Laplacian</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span> <span class="n">Y_G</span><span class="p">,</span> <span class="n">X_C</span><span class="p">,</span> <span class="n">Y_C</span><span class="p">,</span> <span class="n">c_k</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the Laplacian of the basis matrix at the points (X_G,Y_G) from</span>
<span class="sd">    RBFs at the collocation points at (X_C,Y_C), having shape factors c_k. The</span>
<span class="sd">    output is a matrix of side (n_p) x (n_c). The basis can be &#39;c4&#39; or &#39;gauss&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># number of bases (n_b) and points (n_p)</span>
    <span class="n">n_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_C</span><span class="p">);</span> <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># Initialize the matrix</span>
    <span class="n">Lap_RBF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span><span class="n">n_b</span><span class="p">))</span>

    <span class="c1"># What comes next depends on the type of chosen RBF</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Compute the Gaussian</span>
            <span class="n">gaussian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="c1"># Get second derivative along x and y</span>
            <span class="n">Partial_xx</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">X_G</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">gaussian</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">gaussian</span>
            <span class="n">Partial_yy</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">Y_G</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">gaussian</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">gaussian</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Lap_RBF</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">Partial_xx</span><span class="o">+</span><span class="n">Partial_yy</span>

    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Get distance</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Compute the prefactor in the second derivative</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">/</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
            <span class="c1"># Multiply with inner derivative</span>
            <span class="n">Partial_xx</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">X_G</span> <span class="o">-</span> <span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">Partial_yy</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">Y_G</span> <span class="o">-</span> <span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Compute Laplacian</span>
            <span class="n">Laplacian</span> <span class="o">=</span> <span class="n">Partial_xx</span> <span class="o">+</span> <span class="n">Partial_yy</span>
            <span class="c1"># Compact support</span>
            <span class="n">Laplacian</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Lap_RBF</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">Laplacian</span>

    <span class="c1"># Return the matrix</span>
    <span class="k">return</span> <span class="n">Lap_RBF</span>


<span class="c1"># =============================================================================</span>
<span class="c1">#  RBF functions in 3D</span>
<span class="c1">#  Includes: Phi_RBF_2D, Phi_RBF_2D_x, Phi_RBF_2D_y, Phi_RBF_2D_Laplacian</span>
<span class="c1"># =============================================================================</span>

<span class="k">def</span> <span class="nf">Phi_RBF_3D</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span> <span class="n">Y_G</span><span class="p">,</span> <span class="n">Z_G</span><span class="p">,</span> <span class="n">X_C</span><span class="p">,</span> <span class="n">Y_C</span><span class="p">,</span> <span class="n">Z_C</span><span class="p">,</span> <span class="n">c_k</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the basis matrix at the points (X_G,Y_G,Z_G) from RBFs at the collocation points</span>
<span class="sd">    at (X_C,Y_C,Z_C), having shape factors c_k. The output is a matrix of side (n_p) x (n_c).</span>
<span class="sd">    The basis can be &#39;c4&#39; or &#39;gauss&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This is the contribution of the RBF part</span>
    <span class="n">n_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_C</span><span class="p">);</span> <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="n">Phi_RBF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_b</span><span class="p">))</span>

    <span class="c1"># What comes next depends on the type of chosen RBF</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Compute the Gaussian</span>
            <span class="n">gaussian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Phi_RBF</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaussian</span>

    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Get distance</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Compute Phi</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">d</span><span class="o">/</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">d</span><span class="o">/</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">5</span>
            <span class="c1"># Compact support</span>
            <span class="n">phi</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Phi_RBF</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span>

    <span class="k">return</span> <span class="n">Phi_RBF</span>


<span class="k">def</span> <span class="nf">Phi_RBF_3D_x</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span> <span class="n">Y_G</span><span class="p">,</span> <span class="n">Z_G</span><span class="p">,</span> <span class="n">X_C</span><span class="p">,</span> <span class="n">Y_C</span><span class="p">,</span> <span class="n">Z_C</span><span class="p">,</span> <span class="n">c_k</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the derivative along x of the basis matrix at the points (X_G,Y_G,Z_G) from</span>
<span class="sd">    RBFs at the collocation points at (X_C,Y_C,Z_G), having shape factors c_k. The</span>
<span class="sd">    output is a matrix of side (n_p) x (n_c). The basis can be &#39;c4&#39; or &#39;gauss&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># number of bases (n_b) and points (n_p)</span>
    <span class="n">n_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_C</span><span class="p">);</span> <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># Initialize the matrix</span>
    <span class="n">Phi_RBF_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_b</span><span class="p">))</span>

    <span class="c1"># What comes next depends on the type of chosen RBF</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Compute the Gaussian</span>
            <span class="n">gaussian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="c1"># Multiply with inner term and assemble into matrix</span>
            <span class="n">Phi_RBF_x</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">X_G</span> <span class="o">-</span> <span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">*</span><span class="n">gaussian</span>

    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Get distance</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Compute derivative along x</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">10</span><span class="o">/</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="c1"># Compact support</span>
            <span class="n">phi</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Phi_RBF_x</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span>

    <span class="c1"># Return the matrix</span>
    <span class="k">return</span> <span class="n">Phi_RBF_x</span>


<span class="k">def</span> <span class="nf">Phi_RBF_3D_y</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span> <span class="n">Y_G</span><span class="p">,</span> <span class="n">Z_G</span><span class="p">,</span> <span class="n">X_C</span><span class="p">,</span> <span class="n">Y_C</span><span class="p">,</span> <span class="n">Z_C</span><span class="p">,</span> <span class="n">c_k</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the derivative along y of the basis matrix at the points (X_G,Y_G,Z_G) from</span>
<span class="sd">    RBFs at the collocation points at (X_C,Y_C,Z_G), having shape factors c_k. The</span>
<span class="sd">    output is a matrix of side (n_p) x (n_c). The basis can be &#39;c4&#39; or &#39;gauss&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># number of bases (n_b) and points (n_p)</span>
    <span class="n">n_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_C</span><span class="p">);</span> <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># Initialize the matrix</span>
    <span class="n">Phi_RBF_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_b</span><span class="p">))</span>

    <span class="c1"># What comes next depends on the type of chosen RBF</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Compute the Gaussian</span>
            <span class="n">gaussian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="c1"># Multiply with inner term and assemble into matrix</span>
            <span class="n">Phi_RBF_y</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">*</span><span class="n">gaussian</span>

    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Get distance</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Compute derivative along x</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">10</span><span class="o">/</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="c1"># Compact support</span>
            <span class="n">phi</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Phi_RBF_y</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span>

    <span class="c1"># Return the matrix</span>
    <span class="k">return</span> <span class="n">Phi_RBF_y</span>


<span class="k">def</span> <span class="nf">Phi_RBF_3D_z</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span> <span class="n">Y_G</span><span class="p">,</span> <span class="n">Z_G</span><span class="p">,</span> <span class="n">X_C</span><span class="p">,</span> <span class="n">Y_C</span><span class="p">,</span> <span class="n">Z_C</span><span class="p">,</span> <span class="n">c_k</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the derivative along z of the basis matrix at the points (X_G,Y_G,Z_G) from</span>
<span class="sd">    RBFs at the collocation points at (X_C,Y_C,Z_G), having shape factors c_k. The</span>
<span class="sd">    output is a matrix of side (n_p) x (n_c). The basis can be &#39;c4&#39; or &#39;gauss&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># number of bases (n_b) and points (n_p)</span>
    <span class="n">n_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_C</span><span class="p">);</span> <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># Initialize the matrix</span>
    <span class="n">Phi_RBF_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_b</span><span class="p">))</span>

    <span class="c1"># What comes next depends on the type of chosen RBF</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Compute the Gaussian</span>
            <span class="n">gaussian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="c1"># Multiply with inner term and assemble into matrix</span>
            <span class="n">Phi_RBF_z</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">*</span><span class="n">gaussian</span>

    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Get distance</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Compute derivative along x</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">10</span><span class="o">/</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="c1"># Compact support</span>
            <span class="n">phi</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Phi_RBF_z</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span>

    <span class="c1"># Return the matrix</span>
    <span class="k">return</span> <span class="n">Phi_RBF_z</span>

<span class="k">def</span> <span class="nf">Phi_RBF_3D_Laplacian</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span> <span class="n">Y_G</span><span class="p">,</span> <span class="n">Z_G</span><span class="p">,</span> <span class="n">X_C</span><span class="p">,</span> <span class="n">Y_C</span><span class="p">,</span> <span class="n">Z_C</span><span class="p">,</span> <span class="n">c_k</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the Laplacian of the basis matrix at the points (X_G,Y_G,Z_G) from</span>
<span class="sd">    RBFs at the collocation points at (X_C,Y_C,Z_C), having shape factors c_k. The</span>
<span class="sd">    output is a matrix of side (n_p) x (n_c). The basis can be &#39;c4&#39; or &#39;gauss&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># number of bases (n_b) and points (n_p)</span>
    <span class="n">n_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_C</span><span class="p">);</span> <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># Initialize the matrix</span>
    <span class="n">Lap_RBF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span><span class="n">n_b</span><span class="p">))</span>

    <span class="c1"># What comes next depends on the type of chosen RBF</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Compute the Gaussian</span>
            <span class="n">gaussian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="c1"># Get second derivative along x and y</span>
            <span class="n">Partial_xx</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">gaussian</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">gaussian</span>
            <span class="n">Partial_yy</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">gaussian</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">gaussian</span>
            <span class="n">Partial_zz</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">gaussian</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">gaussian</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Lap_RBF</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">Partial_xx</span> <span class="o">+</span> <span class="n">Partial_yy</span>  <span class="o">+</span> <span class="n">Partial_zz</span>

    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span>
        <span class="c1"># Iterate over all basis elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_b</span><span class="p">):</span>
            <span class="c1"># Get distance</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_G</span><span class="o">-</span><span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_G</span><span class="o">-</span><span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Z_G</span><span class="o">-</span><span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Compute the prefactor in the second derivative</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">/</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
            <span class="c1"># Multiply with inner derivative</span>
            <span class="n">Partial_xx</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">X_G</span> <span class="o">-</span> <span class="n">X_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">Partial_yy</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">Y_G</span> <span class="o">-</span> <span class="n">Y_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">Partial_zz</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">Z_G</span> <span class="o">-</span> <span class="n">Z_C</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Compute Laplacian</span>
            <span class="n">Laplacian</span> <span class="o">=</span> <span class="n">Partial_xx</span> <span class="o">+</span> <span class="n">Partial_yy</span> <span class="o">+</span> <span class="n">Partial_zz</span>
            <span class="c1"># Compact support</span>
            <span class="n">Laplacian</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c_k</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Assemble into matrix</span>
            <span class="n">Lap_RBF</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">Laplacian</span>

    <span class="c1"># Return the matrix</span>
    <span class="k">return</span> <span class="n">Lap_RBF</span>

<span class="c1"># =============================================================================</span>
<span class="c1">#  Harmonic functions in 2D</span>
<span class="c1">#  Includes: Phi_H_2D, Phi_H_2D_x, Phi_H_2D_y, Phi_H_2D_Laplacian</span>
<span class="c1"># =============================================================================</span>

<span class="k">def</span> <span class="nf">Phi_H_2D</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span> <span class="n">Y_G</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the basis matrix at the points (X_G, Y_G) from n_hb homogeneous</span>
<span class="sd">    spectral basis element.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The output is a matrix of side (n_p) x (n_hb**4)</span>
    <span class="c1"># Get the number of points</span>
    <span class="n">n_p</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># This is the contribution of the harmonic part (sines and cosines)</span>
    <span class="c1"># The number of harmonic bases will be:</span>
    <span class="n">n_h</span><span class="o">=</span><span class="n">n_hb</span><span class="o">**</span><span class="mi">4</span> <span class="c1"># number of possible dispositions of the harmonic basis in R2.</span>
    <span class="n">Phi_H</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span><span class="n">n_h</span><span class="p">))</span>
    <span class="n">count</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># Counter that will be used to fill the columns</span>
    <span class="c1"># Developer note: the basis is:</span>
    <span class="c1"># sin_k_i_x*cos_k_j_x*sin_k_m_y*sin_k_q_y</span>

    <span class="c1"># Define the indices, for the possible combination of basis elements</span>
    <span class="n">i_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">j_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">m_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">q_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_h</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">k_x_i</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_x_j</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_y_m</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_y_q</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="c1"># To take the differentiation, we use automatic diff style:</span>
        <span class="n">sin_k_i_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">);</span>
        <span class="n">cos_k_j_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">);</span>
        <span class="n">sin_k_m_y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">);</span>
        <span class="n">cos_k_q_y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">);</span>

        <span class="c1"># Assign the column of Phi_H</span>
        <span class="n">Phi_H</span><span class="p">[:,</span><span class="n">count</span><span class="p">]</span><span class="o">=</span><span class="n">sin_k_i_x</span><span class="o">*</span><span class="n">cos_k_j_x</span><span class="o">*</span><span class="n">sin_k_m_y</span><span class="o">*</span><span class="n">cos_k_q_y</span>
        <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">Phi_H</span>


<span class="k">def</span> <span class="nf">Phi_H_2D_x</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span><span class="n">Y_G</span><span class="p">,</span><span class="n">n_hb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create the derivatives along x, Phi_x, for the n_hb harmonic bases,</span>
<span class="sd">    computed on the points (X_G,Y_G)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the number of points</span>
    <span class="n">n_p</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>

    <span class="c1"># This is the contribution of the harmonic part (sines and cosines)</span>
    <span class="c1"># The number of harmonic bases will be:</span>
    <span class="n">n_h</span><span class="o">=</span><span class="n">n_hb</span><span class="o">**</span><span class="mi">4</span> <span class="c1"># number of possible dispositions of the harmonic basis in R2.</span>
    <span class="n">Phi_H_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span><span class="n">n_h</span><span class="p">))</span>
    <span class="n">count</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># Counter that will be used to fill the columns</span>
    <span class="c1"># Developer note: the basis is:</span>
    <span class="c1"># sin_k_i_x*cos_k_j_x*sin_k_m_y*sin_k_q_y</span>

    <span class="c1"># Define the indices, for the possible combination of basis elements</span>
    <span class="n">i_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">j_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">m_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">q_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_h</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">k_x_i</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_x_j</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_y_m</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_y_q</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="c1"># To take the differentiation, we use automatic diff style:</span>
        <span class="n">sin_k_i_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">);</span> <span class="n">cos_k_i_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">cos_k_j_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">);</span> <span class="n">sin_k_j_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">sin_k_m_y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">);</span>
        <span class="n">cos_k_q_y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">);</span>
        <span class="c1"># Assign the column of Phi_H</span>
        <span class="n">Prime</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">sin_k_i_x</span><span class="o">*</span><span class="n">sin_k_j_x</span><span class="o">-</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">cos_k_i_x</span><span class="o">*</span><span class="n">cos_k_j_x</span><span class="p">)</span>
        <span class="n">Phi_H_x</span><span class="p">[:,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">Prime</span><span class="o">*</span><span class="n">sin_k_m_y</span><span class="o">*</span><span class="n">cos_k_q_y</span>
        <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">Phi_H_x</span>


<span class="k">def</span> <span class="nf">Phi_H_2D_y</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span><span class="n">Y_G</span><span class="p">,</span><span class="n">n_hb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create the derivatives along y, Phi_y, for the n_hb harmonic bases,</span>
<span class="sd">    computed on the points (X_G,Y_G)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the number of points</span>
    <span class="n">n_p</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>

    <span class="c1"># This is the contribution of the harmonic part (sines and cosines)</span>
    <span class="c1"># The number of harmonic bases will be:</span>
    <span class="n">n_h</span><span class="o">=</span><span class="n">n_hb</span><span class="o">**</span><span class="mi">4</span> <span class="c1"># number of possible dispositions of the harmonic basis in R2.</span>
    <span class="n">Phi_H_y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span><span class="n">n_h</span><span class="p">))</span>
    <span class="n">count</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># Counter that will be used to fill the columns</span>
    <span class="c1"># Developer note: the basis is:</span>
    <span class="c1"># sin_k_i_x*cos_k_j_x*sin_k_m_y*sin_k_q_y</span>

    <span class="c1"># Define the indices, for the possible combination of basis elements</span>
    <span class="n">i_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">j_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">m_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">q_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_h</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">k_x_i</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_x_j</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_y_m</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_y_q</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="c1"># To take the differentiation, we use automatic diff style:</span>
        <span class="n">sin_k_i_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">);</span>
        <span class="n">cos_k_j_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">);</span>
        <span class="n">sin_k_m_y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">);</span> <span class="n">cos_k_m_y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>
        <span class="n">cos_k_q_y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">);</span> <span class="n">sin_k_q_y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>

        <span class="c1"># Assign the column of Phi_H</span>
        <span class="n">Prime</span><span class="o">=-</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">sin_k_m_y</span><span class="o">*</span><span class="n">sin_k_q_y</span><span class="o">-</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">cos_k_m_y</span><span class="o">*</span><span class="n">cos_k_q_y</span><span class="p">)</span>
        <span class="n">Phi_H_y</span><span class="p">[:,</span><span class="n">count</span><span class="p">]</span><span class="o">=</span><span class="n">Prime</span><span class="o">*</span><span class="n">sin_k_i_x</span><span class="o">*</span><span class="n">cos_k_j_x</span>
        <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">Phi_H_y</span>


<span class="k">def</span> <span class="nf">Phi_H_2D_Laplacian</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span><span class="n">Y_G</span><span class="p">,</span><span class="n">n_hb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create the Laplacian L, for the n_hb harmonic bases,</span>
<span class="sd">    computed on the points (X_G, Y_G)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># number of points</span>
    <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>

    <span class="c1"># The number of harmonic bases will be:</span>
    <span class="n">n_h</span> <span class="o">=</span> <span class="n">n_hb</span><span class="o">**</span><span class="mi">4</span> <span class="c1"># number of possible dispositions of the harmonic basis in R2.</span>
    <span class="n">Lap_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span><span class="n">n_h</span><span class="p">))</span>
    <span class="n">count</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># Counter that will be used to fill the columns</span>
    <span class="c1"># Developer note: the basis is:</span>
    <span class="c1"># sin_k_i_x*cos_k_j_x*sin_k_m_y*sin_k_q_y</span>

    <span class="c1"># Define the indices, for the possible combination of basis elements</span>
    <span class="n">i_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">j_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">m_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">q_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_h</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">k_x_i</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">1</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_x_j</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">1</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_y_m</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">1</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_y_q</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">1</span> <span class="c1"># This goes with cosines</span>
        <span class="c1"># To take the differentiation, we use automatic diff style:</span>
        <span class="n">sin_k_i_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">);</span> <span class="n">cos_k_i_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">cos_k_j_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">);</span> <span class="n">sin_k_j_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">sin_k_m_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">);</span> <span class="n">cos_k_m_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>
        <span class="n">cos_k_q_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">);</span> <span class="n">sin_k_q_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>

        <span class="c1"># Compute the derivatives of the harmonic basis sin_k_i_x</span>
        <span class="n">phi_ijmq_xx</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin_k_m_y</span><span class="o">*</span><span class="n">cos_k_q_y</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">cos_k_i_x</span><span class="o">*</span><span class="n">sin_k_j_x</span><span class="o">+</span>
                                         <span class="p">(</span><span class="n">k_x_j</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">k_x_i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sin_k_i_x</span><span class="o">*</span><span class="n">cos_k_j_x</span><span class="p">)</span>

        <span class="n">phi_ijmq_yy</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin_k_i_x</span><span class="o">*</span><span class="n">cos_k_j_x</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">cos_k_m_y</span><span class="o">*</span><span class="n">sin_k_q_y</span><span class="o">+</span>\
                                            <span class="p">(</span><span class="n">k_y_q</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">k_y_m</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sin_k_m_y</span><span class="o">*</span><span class="n">cos_k_q_y</span><span class="p">)</span>
        <span class="c1"># Assign the column of the Laplacian</span>
        <span class="n">Lap_H</span><span class="p">[:,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi_ijmq_xx</span> <span class="o">+</span> <span class="n">phi_ijmq_yy</span>

    <span class="k">return</span> <span class="n">Lap_H</span>


<span class="k">def</span> <span class="nf">Phi_H_3D</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span><span class="n">Y_G</span><span class="p">,</span><span class="n">Z_G</span><span class="p">,</span><span class="n">n_hb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the basis matrix at the points (X_G, Y_G, Z_G) from n_hb homogeneous</span>
<span class="sd">    spectral basis element.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The output is a matrix of side (n_p) x (n_hb**4)</span>
    <span class="c1"># Get the number of points</span>
    <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># This is the contribution of the harmonic part (sines and cosines)</span>
    <span class="c1"># The number of harmonic bases will be:</span>
    <span class="n">n_h</span> <span class="o">=</span> <span class="n">n_hb</span><span class="o">**</span><span class="mi">6</span> <span class="c1"># number of possible dispositions of the harmonic basis in R2.</span>
    <span class="n">Phi_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_h</span><span class="p">))</span>
    <span class="c1"># Developer note: the basis is:</span>
    <span class="c1"># sin_k_i_x*cos_k_j_x*sin_k_m_y*sin_k_q_y*sin_k_r_z*sin_k_s_z</span>
    <span class="n">i_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">j_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">m_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">q_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">r_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">s_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_h</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="c1"># print(i, j, l, m)</span>
        <span class="n">k_x_i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_x_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_y_m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_y_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_y_r</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_y_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="c1"># To take the differentiation, we use automatic diff style:</span>
        <span class="n">sin_k_i_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">cos_k_j_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">sin_k_m_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>
        <span class="n">cos_k_q_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>
        <span class="n">sin_k_r_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_r</span><span class="o">*</span><span class="n">Z_G</span><span class="p">)</span>
        <span class="n">cos_k_s_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_s</span><span class="o">*</span><span class="n">Z_G</span><span class="p">)</span>

        <span class="c1"># Assign the column of Phi_H</span>
        <span class="n">Phi_H</span><span class="p">[:,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_k_i_x</span><span class="o">*</span><span class="n">cos_k_j_x</span> <span class="o">*</span> <span class="n">sin_k_m_y</span><span class="o">*</span><span class="n">cos_k_q_y</span> <span class="o">*</span> <span class="n">sin_k_r_z</span><span class="o">*</span><span class="n">cos_k_s_z</span>

    <span class="k">return</span> <span class="n">Phi_H</span>

<span class="k">def</span> <span class="nf">Phi_H_3D_x</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span><span class="n">Y_G</span><span class="p">,</span><span class="n">Z_G</span><span class="p">,</span><span class="n">n_hb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create the derivatives along x, Phi_x, for the n_hb harmonic bases,</span>
<span class="sd">    computed on the points (X_G, Y_G, Z_G)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The output is a matrix of side (n_p) x (n_hb**4)</span>
    <span class="c1"># Get the number of points</span>
    <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># This is the contribution of the harmonic part (sines and cosines)</span>
    <span class="c1"># The number of harmonic bases will be:</span>
    <span class="n">n_h</span> <span class="o">=</span> <span class="n">n_hb</span><span class="o">**</span><span class="mi">6</span> <span class="c1"># number of possible dispositions of the harmonic basis in R2.</span>
    <span class="n">Phi_H_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_h</span><span class="p">))</span>
    <span class="c1"># Developer note: the basis is:</span>
    <span class="c1"># sin_k_i_x*cos_k_j_x*sin_k_m_y*sin_k_q_y*sin_k_r_z*sin_k_s_z</span>
    <span class="n">i_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">j_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">m_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">q_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">r_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">s_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_h</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="c1"># print(i, j, l, m)</span>
        <span class="n">k_x_i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_x_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_y_m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_y_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_z_r</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_z_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="c1"># To take the differentiation, we use automatic diff style:</span>
        <span class="n">sin_k_i_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">);</span> <span class="n">cos_k_i_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">cos_k_j_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">);</span> <span class="n">sin_k_j_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">sin_k_m_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>
        <span class="n">cos_k_q_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>
        <span class="n">sin_k_r_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_z_r</span><span class="o">*</span><span class="n">Z_G</span><span class="p">)</span>
        <span class="n">cos_k_s_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_z_s</span><span class="o">*</span><span class="n">Z_G</span><span class="p">)</span>

        <span class="c1"># Assign the column of Phi_H_x</span>
        <span class="n">Prime</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">sin_k_i_x</span><span class="o">*</span><span class="n">sin_k_j_x</span> <span class="o">-</span> <span class="n">k_x_i</span><span class="o">*</span><span class="n">cos_k_i_x</span><span class="o">*</span><span class="n">cos_k_j_x</span><span class="p">)</span>
        <span class="n">Phi_H_x</span><span class="p">[:,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">Prime</span> <span class="o">*</span> <span class="n">sin_k_m_y</span><span class="o">*</span><span class="n">cos_k_q_y</span> <span class="o">*</span> <span class="n">sin_k_r_z</span><span class="o">*</span><span class="n">cos_k_s_z</span>

    <span class="k">return</span> <span class="n">Phi_H_x</span>

<span class="k">def</span> <span class="nf">Phi_H_3D_y</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span><span class="n">Y_G</span><span class="p">,</span><span class="n">Z_G</span><span class="p">,</span><span class="n">n_hb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create the derivatives along y, Phi_y, for the n_hb harmonic bases,</span>
<span class="sd">    computed on the points (X_G, Y_G, Z_G)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The output is a matrix of side (n_p) x (n_hb**4)</span>
    <span class="c1"># Get the number of points</span>
    <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># This is the contribution of the harmonic part (sines and cosines)</span>
    <span class="c1"># The number of harmonic bases will be:</span>
    <span class="n">n_h</span> <span class="o">=</span> <span class="n">n_hb</span><span class="o">**</span><span class="mi">6</span> <span class="c1"># number of possible dispositions of the harmonic basis in R2.</span>
    <span class="n">Phi_H_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_h</span><span class="p">))</span>
    <span class="c1"># Developer note: the basis is:</span>
    <span class="c1"># sin_k_i_x*cos_k_j_x*sin_k_m_y*sin_k_q_y*sin_k_r_z*sin_k_s_z</span>
    <span class="n">i_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">j_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">m_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">q_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">r_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">s_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_h</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="c1"># print(i, j, l, m)</span>
        <span class="n">k_x_i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_x_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_y_m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_y_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_z_r</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_z_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="c1"># To take the differentiation, we use automatic diff style:</span>
        <span class="n">sin_k_i_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">cos_k_j_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">sin_k_m_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">);</span> <span class="n">cos_k_m_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>
        <span class="n">cos_k_q_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">);</span> <span class="n">sin_k_q_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>
        <span class="n">sin_k_r_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_z_r</span><span class="o">*</span><span class="n">Z_G</span><span class="p">)</span>
        <span class="n">cos_k_s_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_z_s</span><span class="o">*</span><span class="n">Z_G</span><span class="p">)</span>

        <span class="c1"># Assign the column of Phi_H_y</span>
        <span class="n">Prime</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">sin_k_m_y</span><span class="o">*</span><span class="n">sin_k_q_y</span> <span class="o">-</span> <span class="n">k_y_q</span><span class="o">*</span><span class="n">cos_k_m_y</span><span class="o">*</span><span class="n">cos_k_q_y</span><span class="p">)</span>
        <span class="n">Phi_H_y</span><span class="p">[:,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">Prime</span> <span class="o">*</span> <span class="n">sin_k_i_x</span><span class="o">*</span><span class="n">cos_k_j_x</span> <span class="o">*</span> <span class="n">sin_k_r_z</span><span class="o">*</span><span class="n">cos_k_s_z</span>

    <span class="k">return</span> <span class="n">Phi_H_y</span>

<span class="k">def</span> <span class="nf">Phi_H_3D_z</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span><span class="n">Y_G</span><span class="p">,</span><span class="n">Z_G</span><span class="p">,</span><span class="n">n_hb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create the derivatives along z, Phi_z, for the n_hb harmonic bases,</span>
<span class="sd">    computed on the points (X_G, Y_G, Z_G)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The output is a matrix of side (n_p) x (n_hb**4)</span>
    <span class="c1"># Get the number of points</span>
    <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># This is the contribution of the harmonic part (sines and cosines)</span>
    <span class="c1"># The number of harmonic bases will be:</span>
    <span class="n">n_h</span> <span class="o">=</span> <span class="n">n_hb</span><span class="o">**</span><span class="mi">6</span> <span class="c1"># number of possible dispositions of the harmonic basis in R2.</span>
    <span class="n">Phi_H_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_h</span><span class="p">))</span>
    <span class="c1"># Developer note: the basis is:</span>
    <span class="c1"># sin_k_i_x*cos_k_j_x*sin_k_m_y*sin_k_q_y*sin_k_r_z*sin_k_s_z</span>
    <span class="n">i_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">j_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">m_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">q_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">r_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">s_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_h</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="c1"># print(i, j, l, m)</span>
        <span class="n">k_x_i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_x_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_y_m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_y_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_z_r</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_z_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="c1"># To take the differentiation, we use automatic diff style:</span>
        <span class="n">sin_k_i_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">cos_k_j_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">sin_k_m_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>
        <span class="n">cos_k_q_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>
        <span class="n">sin_k_r_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_z_r</span><span class="o">*</span><span class="n">Z_G</span><span class="p">);</span> <span class="n">cos_k_r_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_z_r</span><span class="o">*</span><span class="n">Z_G</span><span class="p">)</span>
        <span class="n">cos_k_s_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_z_s</span><span class="o">*</span><span class="n">Z_G</span><span class="p">);</span> <span class="n">sin_k_s_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_z_s</span><span class="o">*</span><span class="n">Z_G</span><span class="p">)</span>

        <span class="c1"># Assign the column of Phi_H_z</span>
        <span class="n">Prime</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">k_z_s</span><span class="o">*</span><span class="n">sin_k_r_z</span><span class="o">*</span><span class="n">sin_k_s_z</span> <span class="o">-</span> <span class="n">k_z_r</span><span class="o">*</span><span class="n">cos_k_r_z</span><span class="o">*</span><span class="n">cos_k_s_z</span><span class="p">)</span>
        <span class="n">Phi_H_z</span><span class="p">[:,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">Prime</span> <span class="o">*</span> <span class="n">sin_k_i_x</span><span class="o">*</span><span class="n">cos_k_j_x</span> <span class="o">*</span> <span class="n">sin_k_m_y</span><span class="o">*</span><span class="n">cos_k_q_y</span>

    <span class="k">return</span> <span class="n">Phi_H_z</span>

<span class="k">def</span> <span class="nf">Phi_H_3D_Laplacian</span><span class="p">(</span><span class="n">X_G</span><span class="p">,</span><span class="n">Y_G</span><span class="p">,</span><span class="n">Z_G</span><span class="p">,</span><span class="n">n_hb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create the Laplacian L, for the n_hb harmonic bases,</span>
<span class="sd">    computed on the points (X_G, Y_G, Z_G)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The output is a matrix of side (n_p) x (n_hb**4)</span>
    <span class="c1"># Get the number of points</span>
    <span class="n">n_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_G</span><span class="p">)</span>
    <span class="c1"># This is the contribution of the harmonic part (sines and cosines)</span>
    <span class="c1"># The number of harmonic bases will be:</span>
    <span class="n">n_h</span> <span class="o">=</span> <span class="n">n_hb</span><span class="o">**</span><span class="mi">6</span> <span class="c1"># number of possible dispositions of the harmonic basis in R2.</span>
    <span class="n">Lap_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_h</span><span class="p">))</span>
    <span class="c1"># Developer note: the basis is:</span>
    <span class="c1"># sin_k_i_x*cos_k_j_x*sin_k_m_y*sin_k_q_y*sin_k_r_z*sin_k_s_z</span>
    <span class="n">i_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">j_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">m_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">q_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">r_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">s_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hb</span><span class="p">),</span> <span class="p">(</span><span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="n">n_hb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_h</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r_s</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s_s</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="c1"># print(i, j, l, m)</span>
        <span class="n">k_x_i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_x_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_y_m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_y_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="n">k_z_r</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with sines</span>
        <span class="n">k_z_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This goes with cosines</span>
        <span class="c1"># To take the differentiation, we use automatic diff style:</span>
        <span class="n">sin_k_i_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">);</span> <span class="n">cos_k_i_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">cos_k_j_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">);</span> <span class="n">sin_k_j_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">X_G</span><span class="p">)</span>
        <span class="n">sin_k_m_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">);</span> <span class="n">cos_k_m_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>
        <span class="n">cos_k_q_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">);</span> <span class="n">sin_k_q_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">Y_G</span><span class="p">)</span>
        <span class="n">sin_k_r_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_z_r</span><span class="o">*</span><span class="n">Z_G</span><span class="p">);</span> <span class="n">cos_k_r_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_z_r</span><span class="o">*</span><span class="n">Z_G</span><span class="p">)</span>
        <span class="n">cos_k_s_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k_z_s</span><span class="o">*</span><span class="n">Z_G</span><span class="p">);</span> <span class="n">sin_k_s_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k_z_s</span><span class="o">*</span><span class="n">Z_G</span><span class="p">)</span>

        <span class="c1"># Compute the derivatives of the harmonic basis sin_k_i_x</span>
        <span class="n">phi_ijmqrs_xx</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin_k_m_y</span><span class="o">*</span><span class="n">cos_k_q_y</span> <span class="o">*</span> <span class="n">sin_k_r_z</span><span class="o">*</span><span class="n">cos_k_s_z</span> <span class="o">*</span> \
            <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k_x_i</span><span class="o">*</span><span class="n">k_x_j</span><span class="o">*</span><span class="n">cos_k_i_x</span><span class="o">*</span><span class="n">sin_k_j_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">k_x_j</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">k_x_i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sin_k_i_x</span><span class="o">*</span><span class="n">cos_k_j_x</span><span class="p">)</span>

        <span class="n">phi_ijmqrs_yy</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin_k_i_x</span><span class="o">*</span><span class="n">cos_k_j_x</span> <span class="o">*</span> <span class="n">sin_k_r_z</span><span class="o">*</span><span class="n">cos_k_s_z</span> <span class="o">*</span> \
            <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k_y_m</span><span class="o">*</span><span class="n">k_y_q</span><span class="o">*</span><span class="n">cos_k_m_y</span><span class="o">*</span><span class="n">sin_k_q_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">k_y_q</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">k_y_m</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sin_k_m_y</span><span class="o">*</span><span class="n">cos_k_q_y</span><span class="p">)</span>

        <span class="n">phi_ijmqrs_zz</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin_k_i_x</span><span class="o">*</span><span class="n">cos_k_j_x</span> <span class="o">*</span> <span class="n">sin_k_m_y</span><span class="o">*</span><span class="n">cos_k_q_y</span> <span class="o">*</span> \
            <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k_z_r</span><span class="o">*</span><span class="n">k_z_s</span><span class="o">*</span><span class="n">cos_k_r_z</span><span class="o">*</span><span class="n">sin_k_s_z</span> <span class="o">+</span> <span class="p">(</span><span class="n">k_z_r</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">k_z_s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sin_k_r_z</span><span class="o">*</span><span class="n">cos_k_s_z</span><span class="p">)</span>

        <span class="c1"># Assign the column of the Laplacian</span>
        <span class="n">Lap_H</span><span class="p">[:,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi_ijmqrs_xx</span> <span class="o">+</span> <span class="n">phi_ijmqrs_yy</span> <span class="o">+</span> <span class="n">phi_ijmqrs_zz</span>

    <span class="k">return</span> <span class="n">Lap_H</span>


<span class="k">def</span> <span class="nf">add_constraint_collocations_2D</span><span class="p">(</span><span class="n">X_constr</span><span class="p">,</span> <span class="n">Y_constr</span><span class="p">,</span> <span class="n">X_C</span><span class="p">,</span> <span class="n">Y_C</span><span class="p">,</span> <span class="n">r_mM</span><span class="p">,</span> <span class="n">eps_l</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function adds collocation points where constraints are set in 2D.</span>

<span class="sd">    ----------------------------------------------------------------------------------------------------------------</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param X_constr: np.ndarray</span>
<span class="sd">        X coordinates of the constraints</span>
<span class="sd">    :param Y_constr: np.ndarray</span>
<span class="sd">        Y coordinates of the constraints</span>
<span class="sd">    :param X_C: np.ndarray</span>
<span class="sd">        X coordinates of the collocation points</span>
<span class="sd">    :param Y_C: np.ndarray</span>
<span class="sd">        Y coordinates of the collocation points</span>
<span class="sd">    :param r_mM: list</span>
<span class="sd">        Minimum and maximum radius of the RBFs</span>
<span class="sd">    :param eps_l: float</span>
<span class="sd">        Value of the RBF at its closest neighbor</span>
<span class="sd">    :param basis: str</span>
<span class="sd">        Type of basis function, must be c4 or Gaussian</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the number of constraints</span>
    <span class="n">n_constr</span> <span class="o">=</span> <span class="n">X_constr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Initialize an empty array for the shape parameters</span>
    <span class="n">c_ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_constr</span><span class="p">)</span>

    <span class="c1"># Check the basis</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span> <span class="c1"># Gaussians</span>
        <span class="c1"># Set the max and min values of c_k</span>
        <span class="n">c_min</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">r_mM</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">c_max</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">r_mM</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># Loop over all constraints</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_constr</span><span class="p">):</span>
            <span class="c1"># Get the distance to all collocation points</span>
            <span class="n">dist_to_colloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_C</span> <span class="o">-</span> <span class="n">X_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_C</span> <span class="o">-</span> <span class="n">Y_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Get the distance to all constraints, except for itself</span>
            <span class="n">dist_to_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_constr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">X_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>\
                                     <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">Y_constr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">Y_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Set the max and min values of c_k</span>
            <span class="n">c_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">eps_l</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dist_to_colloc</span><span class="p">,</span> <span class="n">dist_to_constr</span><span class="p">))</span>
            <span class="c1"># crop to the minimum and maximum value</span>
            <span class="n">c_k</span><span class="p">[</span><span class="n">c_k</span> <span class="o">&lt;</span> <span class="n">c_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_min</span>
            <span class="n">c_k</span><span class="p">[</span><span class="n">c_k</span> <span class="o">&gt;</span> <span class="n">c_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_max</span>
            <span class="c1"># get the maximum value in the case of the Gaussian</span>
            <span class="n">c_ks</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">c_k</span><span class="p">)</span>
        <span class="c1"># for plotting purposes, we store also the diameters</span>
        <span class="n">d_k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">c_ks</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span> <span class="c1"># C4</span>
        <span class="n">c_min</span> <span class="o">=</span> <span class="n">r_mM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">**</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="n">c_max</span> <span class="o">=</span> <span class="n">r_mM</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">**</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_constr</span><span class="p">):</span>
            <span class="c1"># Get the distance to all collocation points</span>
            <span class="n">dist_to_colloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_C</span> <span class="o">-</span> <span class="n">X_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y_C</span> <span class="o">-</span> <span class="n">Y_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Get the distance to all constraints, except for itself</span>
            <span class="n">dist_to_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_constr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">X_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>\
                                     <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">Y_constr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">Y_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Set the max and min values of c_k</span>
            <span class="n">c_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dist_to_colloc</span><span class="p">,</span> <span class="n">dist_to_constr</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">eps_l</span><span class="o">**</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="c1"># crop to the minimum and maximum value</span>
            <span class="n">c_k</span><span class="p">[</span><span class="n">c_k</span> <span class="o">&lt;</span> <span class="n">c_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_min</span>
            <span class="n">c_k</span><span class="p">[</span><span class="n">c_k</span> <span class="o">&gt;</span> <span class="n">c_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_max</span>
            <span class="c1"># get the minimum value in the case of the c4</span>
            <span class="n">c_ks</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">c_k</span><span class="p">)</span>
        <span class="c1"># for plotting purposes, we store also the diameters</span>
        <span class="n">d_k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">c_ks</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">**</span><span class="mf">0.2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">c_ks</span><span class="p">,</span> <span class="n">d_k</span>

<span class="k">def</span> <span class="nf">add_constraint_collocations_3D</span><span class="p">(</span><span class="n">X_constr</span><span class="p">,</span> <span class="n">Y_constr</span><span class="p">,</span> <span class="n">Z_constr</span><span class="p">,</span> <span class="n">X_C</span><span class="p">,</span> <span class="n">Y_C</span><span class="p">,</span> <span class="n">Z_C</span><span class="p">,</span> <span class="n">r_mM</span><span class="p">,</span> <span class="n">eps_l</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function adds collocation points where constraints are set in 3D.</span>

<span class="sd">    ----------------------------------------------------------------------------------------------------------------</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param X_constr: np.ndarray</span>
<span class="sd">        X coordinates of the constraints</span>
<span class="sd">    :param Y_constr: np.ndarray</span>
<span class="sd">        Y coordinates of the constraints</span>
<span class="sd">    :param Z_constr: np.ndarray</span>
<span class="sd">        Z coordinates of the constraints</span>
<span class="sd">    :param X_C: np.ndarray</span>
<span class="sd">        X coordinates of the collocation points</span>
<span class="sd">    :param Y_C: np.ndarray</span>
<span class="sd">        Y coordinates of the collocation points</span>
<span class="sd">    :param Z_C: np.ndarray</span>
<span class="sd">        Z coordinates of the collocation points</span>
<span class="sd">    :param r_mM: list</span>
<span class="sd">        Minimum and maximum radius of the RBFs</span>
<span class="sd">    :param eps_l: float</span>
<span class="sd">        Value of the RBF at its closest neighbor</span>
<span class="sd">    :param basis: str</span>
<span class="sd">        Type of basis function, must be c4 or Gaussian</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the number of constraints</span>
    <span class="n">n_constr</span> <span class="o">=</span> <span class="n">X_constr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Initialize an empty array for the shape parameters</span>
    <span class="n">c_ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_constr</span><span class="p">)</span>

    <span class="c1"># Check the basis</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span> <span class="c1"># Gaussians</span>
        <span class="c1"># Set the max and min values of c_k</span>
        <span class="n">c_min</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">r_mM</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">c_max</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">r_mM</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># Loop over all constraints</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_constr</span><span class="p">):</span>
            <span class="c1"># Get the distance to all collocation points</span>
            <span class="n">dist_to_colloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_C</span> <span class="o">-</span> <span class="n">X_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>\
                                     <span class="p">(</span><span class="n">Y_C</span> <span class="o">-</span> <span class="n">Y_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>\
                                     <span class="p">(</span><span class="n">Z_C</span> <span class="o">-</span> <span class="n">Z_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Get the distance to all constraints, except for itself</span>
            <span class="n">dist_to_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_constr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">X_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>\
                                     <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">Y_constr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">Y_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>\
                                     <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">Z_constr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">Z_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Set the max and min values of c_k</span>
            <span class="n">c_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">eps_l</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dist_to_colloc</span><span class="p">,</span> <span class="n">dist_to_constr</span><span class="p">))</span>
            <span class="c1"># crop to the minimum and maximum value</span>
            <span class="n">c_k</span><span class="p">[</span><span class="n">c_k</span> <span class="o">&lt;</span> <span class="n">c_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_min</span>
            <span class="n">c_k</span><span class="p">[</span><span class="n">c_k</span> <span class="o">&gt;</span> <span class="n">c_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_max</span>
            <span class="c1"># get the maximum value in the case of the Gaussian</span>
            <span class="n">c_ks</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">c_k</span><span class="p">)</span>
        <span class="c1"># for plotting purposes, we store also the diameters</span>
        <span class="n">d_k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">c_ks</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;c4&#39;</span><span class="p">:</span> <span class="c1"># C4</span>
        <span class="n">c_min</span> <span class="o">=</span> <span class="n">r_mM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">**</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="n">c_max</span> <span class="o">=</span> <span class="n">r_mM</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">**</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_constr</span><span class="p">):</span>
            <span class="c1"># Get the distance to all collocation points</span>
            <span class="n">dist_to_colloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X_C</span> <span class="o">-</span> <span class="n">X_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>\
                                     <span class="p">(</span><span class="n">Y_C</span> <span class="o">-</span> <span class="n">Y_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>\
                                     <span class="p">(</span><span class="n">Z_C</span> <span class="o">-</span> <span class="n">Z_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Get the distance to all constraints, except for itself</span>
            <span class="n">dist_to_constr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_constr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">X_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>\
                                     <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">Y_constr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">Y_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>\
                                     <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">Z_constr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">Z_constr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Set the max and min values of c_k</span>
            <span class="n">c_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dist_to_colloc</span><span class="p">,</span> <span class="n">dist_to_constr</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">eps_l</span><span class="o">**</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="c1"># crop to the minimum and maximum value</span>
            <span class="n">c_k</span><span class="p">[</span><span class="n">c_k</span> <span class="o">&lt;</span> <span class="n">c_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_min</span>
            <span class="n">c_k</span><span class="p">[</span><span class="n">c_k</span> <span class="o">&gt;</span> <span class="n">c_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_max</span>
            <span class="c1"># get the minimum value in the case of the c4</span>
            <span class="n">c_ks</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">c_k</span><span class="p">)</span>
        <span class="c1"># for plotting purposes, we store also the diameters</span>
        <span class="n">d_k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">c_ks</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">**</span><span class="mf">0.2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">c_ks</span><span class="p">,</span> <span class="n">d_k</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, P. Sperotto, M. Ratz, M. A. Mendez.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>